/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/* prettier-ignore-start */

/** @jsxRuntime classic */
/** @jsx createPlasmicElementProxy */
/** @jsxFrag React.Fragment */

// This class is auto-generated by Plasmic; please do not edit!
// Plasmic Project: oiawYdGgGKrh1ZZAv15gDZ
// Component: qXHZtzDljvyT

import * as React from "react";

import Head from "next/head";
import Link, { LinkProps } from "next/link";
import { useRouter } from "next/router";

import {
  Flex as Flex__,
  MultiChoiceArg,
  PlasmicDataSourceContextProvider as PlasmicDataSourceContextProvider__,
  PlasmicIcon as PlasmicIcon__,
  PlasmicImg as PlasmicImg__,
  PlasmicLink as PlasmicLink__,
  PlasmicPageGuard as PlasmicPageGuard__,
  SingleBooleanChoiceArg,
  SingleChoiceArg,
  Stack as Stack__,
  StrictProps,
  Trans as Trans__,
  classNames,
  createPlasmicElementProxy,
  deriveRenderOpts,
  ensureGlobalVariants,
  generateOnMutateForSpec,
  generateStateOnChangeProp,
  generateStateOnChangePropForCodeComponents,
  generateStateValueProp,
  get as $stateGet,
  hasVariant,
  initializeCodeComponentStates,
  initializePlasmicStates,
  makeFragment,
  omit,
  pick,
  renderPlasmicSlot,
  set as $stateSet,
  useCurrentUser,
  useDollarState,
  usePlasmicTranslator,
  useTrigger,
  wrapWithClassName
} from "@plasmicapp/react-web";
import {
  DataCtxReader as DataCtxReader__,
  useDataEnv,
  useGlobalActions
} from "@plasmicapp/react-web/lib/host";

import { usePlasmicDataSourceContext } from "@plasmicapp/data-sources-context";
import {
  executePlasmicDataOp,
  usePlasmicDataOp,
  usePlasmicInvalidate
} from "@plasmicapp/react-web/lib/data-sources";

import { SideEffect } from "@plasmicpkgs/plasmic-basic-components";
import Layout from "../../Layout"; // plasmic-import: pAY-hwRYSgy5/component
import Label from "../../Label"; // plasmic-import: _L7DdH4fVzRf/component
import { AntdDatePicker } from "@plasmicpkgs/antd5/skinny/registerDatePicker";
import { datePickerHelpers as AntdDatePicker_Helpers } from "@plasmicpkgs/antd5/skinny/registerDatePicker";
import { TagFilterPrimeReact } from "../../TagFilterPrimeReact"; // plasmic-import: 1J5_BkPImwIs/codeComponent
import Combobox from "../../Combobox"; // plasmic-import: AAXsSjk33gui/component
import MenuSection from "../../MenuSection"; // plasmic-import: z_NkZsZzIrEK/component
import MenuItem from "../../MenuItem"; // plasmic-import: uc7bJMLR_F-c/component
import Select from "../../Select"; // plasmic-import: X18jlD8v21Ca/component
import MolKip from "../../MolKip"; // plasmic-import: 8zniO6bPf7fe/component
import CnKpi from "../../CnKpi"; // plasmic-import: DJwwZ5Fitj5H/component
import OrgSalesCardMix from "../../OrgSalesCardMix"; // plasmic-import: 5ws1bNmXCLoT/component
import { Fetcher } from "@plasmicapp/react-web/lib/data-sources";
import { _useGlobalVariants } from "./plasmic"; // plasmic-import: oiawYdGgGKrh1ZZAv15gDZ/projectModule
import { _useStyleTokens } from "./PlasmicStyleTokensProvider"; // plasmic-import: oiawYdGgGKrh1ZZAv15gDZ/styleTokensProvider
import { _useStyleTokens as useStyleTokens_antd_5_hostless } from "../antd_5_hostless/PlasmicStyleTokensProvider"; // plasmic-import: ohDidvG9XsCeFumugENU3J/styleTokensProvider
import { _useStyleTokens as useStyleTokens_library_tailwind_3_4_colors } from "../library_tailwind_3_4_color_tokens/PlasmicStyleTokensProvider"; // plasmic-import: 5ZtnypMovRHeeP3YTdPCYL/styleTokensProvider
import { _useStyleTokens as useStyleTokens_library_tailwind_3_4_number_tokens } from "../library_tailwind_3_4_number_tokens/PlasmicStyleTokensProvider"; // plasmic-import: 4vjRXvnb4XuY6J15w9oRcQ/styleTokensProvider
import { _useStyleTokens as useStyleTokens_plasmic_rich_components } from "../plasmic_rich_components/PlasmicStyleTokensProvider"; // plasmic-import: jkU633o1Cz7HrJdwdxhVHk/styleTokensProvider

import "@plasmicapp/react-web/lib/plasmic.css";

import projectcss from "./plasmic.module.css"; // plasmic-import: oiawYdGgGKrh1ZZAv15gDZ/projectcss
import sty from "./PlasmicHome.module.css"; // plasmic-import: qXHZtzDljvyT/css

createPlasmicElementProxy;

export type PlasmicHome__VariantMembers = {};
export type PlasmicHome__VariantsArgs = {};
type VariantPropType = keyof PlasmicHome__VariantsArgs;
export const PlasmicHome__VariantProps = new Array<VariantPropType>();

export type PlasmicHome__ArgsType = {};
type ArgPropType = keyof PlasmicHome__ArgsType;
export const PlasmicHome__ArgProps = new Array<ArgPropType>();

export type PlasmicHome__OverridesType = {
  root?: Flex__<"div">;
  sideEffect?: Flex__<typeof SideEffect>;
  layout?: Flex__<typeof Layout>;
  label?: Flex__<typeof Label>;
  timePicker?: Flex__<typeof AntdDatePicker>;
  tagFilterPrimeReact?: Flex__<typeof TagFilterPrimeReact>;
  combobox?: Flex__<typeof Combobox>;
  menuSection?: Flex__<typeof MenuSection>;
  menuItem?: Flex__<typeof MenuItem>;
  select?: Flex__<typeof Select>;
  cnKpi?: Flex__<typeof CnKpi>;
  orgSalesCardMix?: Flex__<typeof OrgSalesCardMix>;
};

export interface DefaultHomeProps {}

const $$ = {};

function useNextRouter() {
  try {
    return useRouter();
  } catch {}
  return undefined;
}

function PlasmicHome__RenderFunc(props: {
  variants: PlasmicHome__VariantsArgs;
  args: PlasmicHome__ArgsType;
  overrides: PlasmicHome__OverridesType;
  forNode?: string;
}) {
  const { variants, overrides, forNode } = props;

  const args = React.useMemo(
    () =>
      Object.assign(
        {},
        Object.fromEntries(
          Object.entries(props.args).filter(([_, v]) => v !== undefined)
        )
      ),
    [props.args]
  );

  const $props = {
    ...args,
    ...variants
  };

  const __nextRouter = useNextRouter();

  const $ctx = useDataEnv?.() || {};
  const refsRef = React.useRef({});
  const $refs = refsRef.current;

  const $globalActions = useGlobalActions?.();

  let [$queries, setDollarQueries] = React.useState<
    Record<string, ReturnType<typeof usePlasmicDataOp>>
  >({});
  const stateSpecs: Parameters<typeof useDollarState>[0] = React.useMemo(
    () => [
      {
        path: "teams",
        type: "private",
        variableType: "array",
        initFunc: ({ $props, $state, $queries, $ctx }) => []
      },
      {
        path: "items",
        type: "private",
        variableType: "array",
        initFunc: ({ $props, $state, $queries, $ctx }) => []
      },
      {
        path: "data",
        type: "private",
        variableType: "array",
        initFunc: ({ $props, $state, $queries, $ctx }) => [
          {
            id: "EBS042",
            Customer: "AADITYA PHARMEX",
            EBSCode: "EBS042",
            HQ: "Chennai",
            Incentive: 2000,
            CreditNote: -500,
            invoices: [
              {
                Invoice: "INV-25-10451",
                PostingDate: "2025-07-05",
                HQ: "HQ-Madurai",
                Incentive: 1200,
                CreditNote: 0
              },
              {
                Invoice: "INV-25-10452",
                PostingDate: "2025-07-10",
                HQ: "HQ-Chennai",
                Incentive: 800,
                CreditNote: -200
              }
            ]
          },
          {
            id: "EBS043",
            Customer: "MEDICARE PLUS",
            EBSCode: "EBS043",
            HQ: "Mumbai",
            Incentive: 3500,
            CreditNote: -150,
            invoices: [
              {
                Invoice: "INV-25-10453",
                PostingDate: "2025-07-08",
                HQ: "HQ-Mumbai",
                Incentive: 2000,
                CreditNote: -100
              },
              {
                Invoice: "INV-25-10454",
                PostingDate: "2025-07-12",
                HQ: "HQ-Pune",
                Incentive: 1500,
                CreditNote: -50
              }
            ]
          },
          {
            id: "EBS044",
            Customer: "PHARMA DISTRIBUTORS",
            EBSCode: "EBS044",
            HQ: "Delhi",
            Incentive: 1800,
            CreditNote: 0,
            invoices: [
              {
                Invoice: "INV-25-10455",
                PostingDate: "2025-07-15",
                HQ: "HQ-Delhi",
                Incentive: 1800,
                CreditNote: 0
              }
            ]
          }
        ]
      },
      {
        path: "timePicker.value",
        type: "private",
        variableType: "text",
        initFunc: ({ $props, $state, $queries, $ctx }) => undefined,

        onMutate: generateOnMutateForSpec("value", AntdDatePicker_Helpers)
      },
      {
        path: "variable",
        type: "private",
        variableType: "array",
        initFunc: ({ $props, $state, $queries, $ctx }) => [
          {
            Customer: "AADITYA PHARMEX",
            EBSCode: "EBS042",
            HQ: "Chennai",
            Incentive: 2000,
            CreditNote: -500,
            invoices: [
              {
                Invoice: "INV-25-10451",
                PostingDate: "2025-07-05",
                HQ: "HQ-Madurai",
                Incentive: 1200,
                CreditNote: 0,
                brands: [
                  {
                    Brand: "PAINFREE",
                    HQ: "HQ-Madurai",
                    Incentive: 1200,
                    CreditNote: 0
                  },
                  {
                    Brand: "VITAMAX",
                    HQ: "HQ-Madurai",
                    Incentive: 0,
                    CreditNote: -100
                  }
                ]
              },
              {
                Invoice: "INV-25-10452",
                PostingDate: "2025-07-10",
                HQ: "HQ-Chennai",
                Incentive: 800,
                CreditNote: -200,
                brands: [
                  {
                    Brand: "PAINFREE",
                    HQ: "HQ-Chennai",
                    Incentive: 800,
                    CreditNote: -200
                  }
                ]
              }
            ]
          },
          {
            Customer: "MEDICARE PLUS",
            EBSCode: "EBS043",
            HQ: "Mumbai",
            Incentive: 3500,
            CreditNote: -150,
            invoices: [
              {
                Invoice: "INV-25-10453",
                PostingDate: "2025-07-08",
                HQ: "HQ-Mumbai",
                Incentive: 2000,
                CreditNote: -100,
                brands: [
                  {
                    Brand: "VITAMAX",
                    HQ: "HQ-Mumbai",
                    Incentive: 1500,
                    CreditNote: 0
                  },
                  {
                    Brand: "PAINFREE",
                    HQ: "HQ-Mumbai",
                    Incentive: 500,
                    CreditNote: -100
                  }
                ]
              },
              {
                Invoice: "INV-25-10454",
                PostingDate: "2025-07-12",
                HQ: "HQ-Pune",
                Incentive: 1500,
                CreditNote: -50,
                brands: [
                  {
                    Brand: "VITAMAX",
                    HQ: "HQ-Pune",
                    Incentive: 1500,
                    CreditNote: -50
                  }
                ]
              }
            ]
          },
          {
            Customer: "PHARMA DISTRIBUTORS",
            EBSCode: "EBS044",
            HQ: "Delhi",
            Incentive: 1800,
            CreditNote: 0,
            invoices: [
              {
                Invoice: "INV-25-10455",
                PostingDate: "2025-07-15",
                HQ: "HQ-Delhi",
                Incentive: 1800,
                CreditNote: 0,
                brands: [
                  {
                    Brand: "PAINFREE",
                    HQ: "HQ-Delhi",
                    Incentive: 1200,
                    CreditNote: 0
                  },
                  {
                    Brand: "VITAMAX",
                    HQ: "HQ-Delhi",
                    Incentive: 600,
                    CreditNote: 0
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        path: "combobox.isOpen",
        type: "private",
        variableType: "boolean",
        initFunc: ({ $props, $state, $queries, $ctx }) => false
      },
      {
        path: "combobox.value",
        type: "private",
        variableType: "text",
        initFunc: ({ $props, $state, $queries, $ctx }) => undefined
      },
      {
        path: "select.isOpen",
        type: "private",
        variableType: "boolean",
        initFunc: ({ $props, $state, $queries, $ctx }) => false
      },
      {
        path: "select.value",
        type: "private",
        variableType: "text",
        initFunc: ({ $props, $state, $queries, $ctx }) => undefined
      },
      {
        path: "date",
        type: "private",
        variableType: "object",
        initFunc: ({ $props, $state, $queries, $ctx }) => ({
          startDate: "2025-08-01",
          endDate: "2025-08-22"
        })
      }
    ],
    [$props, $ctx, $refs]
  );
  const $state = useDollarState(stateSpecs, {
    $props,
    $ctx,
    $queries: $queries,
    $refs
  });
  const dataSourcesCtx = usePlasmicDataSourceContext();
  const plasmicInvalidate = usePlasmicInvalidate();

  const new$Queries: Record<string, ReturnType<typeof usePlasmicDataOp>> = {
    teams: usePlasmicDataOp(() => {
      return {
        sourceId: "kipZkDNi8dCzZdLA5QF7Pw",
        opId: "52b22452-80d6-4ca8-9b98-2ee598493870",
        userArgs: {},
        cacheKey: `plasmic.$.52b22452-80d6-4ca8-9b98-2ee598493870.$.`,
        invalidatedKeys: null,
        roleId: null
      };
    }),
    emp: usePlasmicDataOp(() => {
      return {
        sourceId: "kipZkDNi8dCzZdLA5QF7Pw",
        opId: "3e1fbf6c-ca09-4ea4-8601-d0eeef6184e5",
        userArgs: {},
        cacheKey: `plasmic.$.3e1fbf6c-ca09-4ea4-8601-d0eeef6184e5.$.`,
        invalidatedKeys: null,
        roleId: null
      };
    })
  };
  if (Object.keys(new$Queries).some(k => new$Queries[k] !== $queries[k])) {
    setDollarQueries(new$Queries);

    $queries = new$Queries;
  }

  const styleTokensClassNames = _useStyleTokens();
  const styleTokensClassNames_antd_5_hostless =
    useStyleTokens_antd_5_hostless();
  const styleTokensClassNames_library_tailwind_3_4_colors =
    useStyleTokens_library_tailwind_3_4_colors();
  const styleTokensClassNames_library_tailwind_3_4_number_tokens =
    useStyleTokens_library_tailwind_3_4_number_tokens();
  const styleTokensClassNames_plasmic_rich_components =
    useStyleTokens_plasmic_rich_components();

  return (
    <React.Fragment>
      <Head></Head>

      <style>{`
        body {
          margin: 0;
        }
      `}</style>

      <div className={projectcss.plasmic_page_wrapper}>
        <div
          data-plasmic-name={"root"}
          data-plasmic-override={overrides.root}
          data-plasmic-root={true}
          data-plasmic-for-node={forNode}
          className={classNames(
            projectcss.all,
            projectcss.root_reset,
            projectcss.plasmic_default_styles,
            projectcss.plasmic_mixins,
            styleTokensClassNames,
            styleTokensClassNames_antd_5_hostless,
            styleTokensClassNames_library_tailwind_3_4_colors,
            styleTokensClassNames_library_tailwind_3_4_number_tokens,
            styleTokensClassNames_plasmic_rich_components,
            sty.root
          )}
        >
          <SideEffect
            data-plasmic-name={"sideEffect"}
            data-plasmic-override={overrides.sideEffect}
            className={classNames("__wab_instance", sty.sideEffect)}
            deps={(() => {
              try {
                return [$state.teams, $state.selectedTags, $state.date];
              } catch (e) {
                if (
                  e instanceof TypeError ||
                  e?.plasmicType === "PlasmicUndefinedDataError"
                ) {
                  return undefined;
                }
                throw e;
              }
            })()}
            onMount={async () => {
              const $steps = {};

              $steps["query"] = true
                ? (() => {
                    const actionArgs = {
                      dataOp: {
                        sourceId: "kipZkDNi8dCzZdLA5QF7Pw",
                        opId: "477b8d70-2a30-475b-9c8f-01454d79386c",
                        userArgs: {
                          variables: [
                            $state.date.endDate,

                            $state.teams,

                            $state.date.startDate
                          ]
                        },
                        cacheKey: null,
                        invalidatedKeys: null,
                        roleId: null
                      }
                    };
                    return (async ({ dataOp, continueOnError }) => {
                      try {
                        const response = await executePlasmicDataOp(dataOp, {
                          userAuthToken: dataSourcesCtx?.userAuthToken,
                          user: dataSourcesCtx?.user
                        });
                        await plasmicInvalidate(dataOp.invalidatedKeys);
                        return response;
                      } catch (e) {
                        if (!continueOnError) {
                          throw e;
                        }
                        return e;
                      }
                    })?.apply(null, [actionArgs]);
                  })()
                : undefined;
              if (
                $steps["query"] != null &&
                typeof $steps["query"] === "object" &&
                typeof $steps["query"].then === "function"
              ) {
                $steps["query"] = await $steps["query"];
              }

              $steps["_switch"] = false
                ? (() => {
                    const actionArgs = {
                      variable: {
                        objRoot: $state,
                        variablePath: ["data"]
                      },
                      operation: 0,
                      value: (() => {
                        const w =
                          $steps.query?.data?.response?.data?.withPurpose
                            ?.edges ?? [];
                        const wo =
                          $steps.query?.data?.response?.data?.withoutPurpose
                            ?.edges ?? [];
                        const tEdges =
                          $steps.query?.data?.response?.data?.Targets?.edges ??
                          [];
                        const invoices = [...w, ...wo];

                        const rows =
                          $ctx.fn.explodeWithParent(invoices, {
                            itemPath: "node.items"
                          }) || [];
                        return { rows };
                      })()
                    };
                    return (({ variable, value, startIndex, deleteCount }) => {
                      if (!variable) {
                        return;
                      }
                      const { objRoot, variablePath } = variable;

                      $stateSet(objRoot, variablePath, value);
                      return value;
                    })?.apply(null, [actionArgs]);
                  })()
                : undefined;
              if (
                $steps["_switch"] != null &&
                typeof $steps["_switch"] === "object" &&
                typeof $steps["_switch"].then === "function"
              ) {
                $steps["_switch"] = await $steps["_switch"];
              }

              $steps["logic"] = true
                ? (() => {
                    const actionArgs = {
                      customFunction: async () => {
                        return (() => {
                          const w =
                            $steps.query?.data?.response?.data?.withPurpose
                              ?.edges ?? [];
                          const wo =
                            $steps.query?.data?.response?.data?.withoutPurpose
                              ?.edges ?? [];
                          const tEdges =
                            $steps.query?.data?.response?.data?.Targets
                              ?.edges ?? [];
                          const invoices = [...w, ...wo];

                          const norm = s =>
                            String(s ?? "")
                              .trim()
                              .toLowerCase();
                          const parseFilterList = val => {
                            if (Array.isArray(val))
                              return val.map(norm).filter(Boolean);
                            if (typeof val === "string")
                              return val
                                .split(/[,;\n]/g)
                                .map(norm)
                                .filter(Boolean);
                            return [];
                          };
                          const TEAM_LIST = parseFilterList($state.teams);
                          const ALLOW_TEAMS = new Set(TEAM_LIST);
                          const allowAllTeams = ALLOW_TEAMS.size === 0;
                          const isTeamAllowed = name =>
                            allowAllTeams || ALLOW_TEAMS.has(norm(name));
                          const rowsAll =
                            $ctx.fn.explodeWithParent(invoices, {
                              itemPath: "node.items"
                            }) || [];
                          const teamKey = r =>
                            (r?.fsl_elbrit_sales_team__name ?? "Unknown")
                              .toString()
                              .trim();
                          const hqKey = r =>
                            (r?.territory__name ?? "Unknown").toString().trim();
                          const rows = rowsAll.filter(r =>
                            isTeamAllowed(teamKey(r))
                          );
                          const invoiceKey = r =>
                            (r?.name ?? r?.node?.name ?? "").toString();
                          const round2 = v =>
                            Math.round((Number(v) || 0) * 100) / 100;
                          const toNum = v => {
                            const n = Number(v);
                            return Number.isFinite(n) ? n : 0;
                          };
                          const pstr = n =>
                            (n?.fsl_purpose ?? "")
                              .toString()
                              .trim()
                              .toUpperCase();
                          const isBreakage = n =>
                            pstr(n) === "BREAKAGE" || pstr(n) === "BREKAGE";
                          const isExpired = n => pstr(n) === "EXPIRED";
                          const isReturnFlag = n => pstr(n) === "SALES_RETURN";
                          const isRateDiff = n => {
                            const p = pstr(n)
                              .replace(/[-_]+/g, " ")
                              .replace(/\s+/g, " ")
                              .trim();
                            return p === "RATE DIFFERENCE" || p === "RD";
                          };
                          const uniqBy = (arr, keyFn) => {
                            const seen = new Set(),
                              out = [];
                            for (const x of arr) {
                              const k = keyFn(x);
                              if (!seen.has(k)) {
                                seen.add(k);
                                out.push(x);
                              }
                            }
                            return out;
                          };
                          const isClaimItem = r =>
                            toNum(r?.fsl_claim ?? r?.fslClaim) === 1;
                          const isInvoiceOffItem = r =>
                            toNum(r?.is_free_item ?? r?.isFreeItem) === 1;
                          const lineProductOfferValue = r =>
                            toNum(r?.qty) *
                            toNum(r?.fsl_pts ?? r?.fsl_PTS ?? r?.fslPts);
                          const linePriceOfferValue = r =>
                            toNum(
                              r?.amount ?? r?.net_amount ?? r?.item_amount ?? 0
                            );
                          const getLineAmount = r => {
                            if (r?.amount != null) return toNum(r.amount);
                            if (r?.net_amount != null)
                              return toNum(r.net_amount);
                            if (r?.item_amount != null)
                              return toNum(r.item_amount);
                            const qty = toNum(r.qty ?? r.quantity);
                            const rate = toNum(r.rate ?? r.fsl_pts ?? r.price);
                            return round2(qty * rate);
                          };
                          const hash32 = str => {
                            let h = 2166136261;
                            const s = String(str);
                            for (let i = 0; i < s.length; i++) {
                              h ^= s.charCodeAt(i);
                              h = Math.imul(h, 16777619);
                            }
                            return h >>> 0;
                          };
                          const hslToHex = (h, s, l) => {
                            s /= 100;
                            l /= 100;
                            const k = n => (n + h / 30) % 12;
                            const a = s * Math.min(l, 1 - l);
                            const f = n =>
                              l -
                              a *
                                Math.max(
                                  -1,
                                  Math.min(k(n) - 3, Math.min(9 - k(n), 1))
                                );
                            const toHex = x =>
                              Math.round(x * 255)
                                .toString(16)
                                .padStart(2, "0");
                            return `#${toHex(f(0))}${toHex(f(8))}${toHex(
                              f(4)
                            )}`;
                          };
                          const pickTeamColor = teamName =>
                            hslToHex(
                              hash32(teamName || "Unknown") % 360,
                              72,
                              48
                            );
                          const HQ_COLOR = "#2798F5";
                          const byTeamHQ = rows.reduce((acc, r) => {
                            const t = teamKey(r),
                              h = hqKey(r);
                            acc[t] ||= {};
                            (acc[t][h] ||= []).push(r);
                            return acc;
                          }, {});
                          const invAgg_TCH = {};
                          const offerCustByTeamHQ = {};
                          const offerInv_TCH = {};
                          const rdSeen = new Set();
                          const custKey = r =>
                            (
                              r?.customer_name ??
                              r?.customer__name ??
                              r?.customer ??
                              r?.party__name ??
                              "Unknown"
                            )
                              .toString()
                              .trim();
                          const custEBS = r =>
                            (
                              r?.whg_ebs_code ??
                              r?.ebs_code ??
                              r?.customer__code ??
                              r?.customer_code ??
                              r?.party_code ??
                              r?.fsl_customer_code ??
                              ""
                            )
                              .toString()
                              .trim();
                          const getPostDate = r =>
                            r?.posting_date ?? r?.postingDate ?? null;
                          const isCreditEligible = r =>
                            isExpired(r) || isReturnFlag(r) || isBreakage(r);
                          const isSalesLine = r =>
                            toNum(r?.is_return) === 0 && !isCreditEligible(r);
                          const isReturnLine = r => isCreditEligible(r);
                          for (const r of rows) {
                            const team = teamKey(r);
                            if (!isTeamAllowed(team)) continue;
                            const hq = hqKey(r);
                            const cust = custKey(r);
                            const ebs = custEBS(r);
                            const invId = invoiceKey(r);
                            const postDate = getPostDate(r);
                            const amt = getLineAmount(r);
                            const kInv = `${team}|${cust}|${hq}|${ebs}|${invId}`;
                            if (!invAgg_TCH[kInv]) {
                              invAgg_TCH[kInv] = {
                                team,
                                customer: cust,
                                hq,
                                ebs,
                                Invoice: invId,
                                PostingDate: postDate,
                                salesNet: 0,
                                creditNote: 0,
                                itemsAll: []
                              };
                            }
                            invAgg_TCH[kInv].itemsAll.push({
                              item_name: r.item_name,
                              item_code: r.item_code__name,
                              qty: toNum(r.qty),
                              rate: toNum(r.rate ?? r.fsl_pts),
                              amount: amt,
                              brand: r.brand,
                              purpose: r.fsl_purpose,
                              _isClaim: isClaimItem(r),
                              _isFree: isInvoiceOffItem(r),
                              _isRD: isRateDiff(r)
                            });
                            if (isSalesLine(r))
                              invAgg_TCH[kInv].salesNet += amt;
                            if (isReturnLine(r))
                              invAgg_TCH[kInv].creditNote += amt;
                            const offerTHC = `${team}|${hq}|${cust}|${ebs}`;
                            if (
                              isClaimItem(r) ||
                              isInvoiceOffItem(r) ||
                              isRateDiff(r)
                            ) {
                              offerCustByTeamHQ[offerTHC] ||= {
                                team,
                                hq,
                                customer: cust,
                                ebs,
                                claim: 0,
                                prod: 0,
                                price: 0,
                                rd: 0
                              };
                              if (!offerInv_TCH[kInv]) {
                                offerInv_TCH[kInv] = {
                                  team,
                                  customer: cust,
                                  hq,
                                  ebs,
                                  Invoice: invId,
                                  PostingDate: postDate,
                                  claim: 0,
                                  prod: 0,
                                  price: 0,
                                  rd: 0,
                                  itemsOffer: []
                                };
                              }
                            }
                            if (isClaimItem(r)) {
                              const v = lineProductOfferValue(r);
                              offerCustByTeamHQ[offerTHC].claim += v;
                              offerInv_TCH[kInv].claim += v;
                              offerInv_TCH[kInv].itemsOffer.push({
                                item_name: r.item_name,
                                qty: toNum(r.qty),
                                amount: v,
                                purpose: r?.fsl_purpose
                              });
                            }
                            if (isInvoiceOffItem(r) && !isClaimItem(r)) {
                              const v = lineProductOfferValue(r);
                              offerCustByTeamHQ[offerTHC].prod += v;
                              offerInv_TCH[kInv].prod += v;
                              offerInv_TCH[kInv].itemsOffer.push({
                                item_name: r.item_name,
                                qty: toNum(r.qty),
                                amount: v,
                                purpose: r?.fsl_purpose
                              });
                            }
                            if (isInvoiceOffItem(r) && isClaimItem(r)) {
                              const v = linePriceOfferValue(r);
                              offerCustByTeamHQ[offerTHC].price += v;
                              offerInv_TCH[kInv].price += v;
                              offerInv_TCH[kInv].itemsOffer.push({
                                item_name: r.item_name,
                                qty: toNum(r.qty),
                                amount: v,
                                purpose: r?.fsl_purpose
                              });
                            }
                            if (isRateDiff(r)) {
                              const rdKey = `${team}|${hq}|${invId}`;
                              if (!rdSeen.has(rdKey)) {
                                rdSeen.add(rdKey);
                                const rdAmt = toNum(
                                  r.total ?? r.grand_total ?? r.net_total ?? 0
                                );
                                offerCustByTeamHQ[offerTHC].rd += rdAmt;
                                if (!offerInv_TCH[kInv]) {
                                  offerInv_TCH[kInv] = {
                                    team,
                                    customer: cust,
                                    hq,
                                    ebs,
                                    Invoice: invId,
                                    PostingDate: postDate,
                                    claim: 0,
                                    prod: 0,
                                    price: 0,
                                    rd: 0,
                                    itemsOffer: []
                                  };
                                }
                                offerInv_TCH[kInv].rd += rdAmt;
                                offerInv_TCH[kInv].itemsOffer.push({
                                  item_name: "RATE DIFFERENCE",
                                  qty: 0,
                                  amount: rdAmt,
                                  purpose: "RATE DIFFERENCE"
                                });
                              }
                            }
                          }
                          const offerInvAggTH = {};
                          for (const iv of Object.values(offerInv_TCH)) {
                            const key = `${iv.team}|${iv.hq}`;
                            if (!offerInvAggTH[key])
                              offerInvAggTH[key] = {
                                team: iv.team,
                                hq: iv.hq,
                                claim: 0,
                                prod: 0,
                                price: 0,
                                rd: 0
                              };
                            offerInvAggTH[key].claim += round2(iv.claim);
                            offerInvAggTH[key].prod += round2(iv.prod);
                            offerInvAggTH[key].price += round2(iv.price);
                            offerInvAggTH[key].rd += round2(iv.rd);
                          }
                          const offersByTeamHQ = Object.values(
                            offerInvAggTH
                          ).map(o => ({
                            team: o.team,
                            hq: o.hq,
                            claimValue: round2(o.claim),
                            invoiceOffValue: round2(o.prod),
                            invoiceOffPriceValue: round2(o.price),
                            rdValue: round2(o.rd)
                          }));
                          const offersByKey = offersByTeamHQ.reduce(
                            (m, o) => ((m[`${o.team}|${o.hq}`] = o), m),
                            {}
                          );
                          const tNodesAll = tEdges
                            .map(e => e.node)
                            .filter(Boolean);
                          const teamKeyT = n =>
                            (n?.salesteam__name ?? "Unknown").toString().trim();
                          const hqKeyT = n =>
                            (n?.hq__name ?? "Unknown").toString().trim();
                          const tNodes = tNodesAll.filter(n =>
                            isTeamAllowed(teamKeyT(n))
                          );
                          const targetByTeamHQ = {};
                          let targetMonth = null;
                          for (const n of tNodes) {
                            const team = teamKeyT(n),
                              hq = hqKeyT(n),
                              key = `${team}|${hq}`;
                            const val = Number(n?.value ?? 0);
                            targetByTeamHQ[key] =
                              (targetByTeamHQ[key] ?? 0) + val;
                            if (!targetMonth && n?.date) targetMonth = n.date;
                          }
                          const teamHqTotals = [];
                          Object.entries(byTeamHQ).forEach(([team, hqMap]) => {
                            Object.entries(hqMap).forEach(([hq, arr]) => {
                              const invs = uniqBy(arr, invoiceKey);
                              const grossValue = round2(
                                invs.reduce(
                                  (s, n) =>
                                    s +
                                    Math.abs(
                                      toNum(
                                        n.total ??
                                          n.grand_total ??
                                          n.net_total ??
                                          0
                                      )
                                    ),
                                  0
                                )
                              );
                              const netValue = round2(
                                invs.reduce(
                                  (s, n) =>
                                    toNum(n.is_return) === 0
                                      ? s +
                                        toNum(
                                          n.total ??
                                            n.grand_total ??
                                            n.net_total ??
                                            0
                                        )
                                      : s,
                                  0
                                )
                              );
                              const CNValue = round2(
                                invs.reduce(
                                  (s, n) =>
                                    toNum(n.is_return) !== 0
                                      ? s +
                                        toNum(
                                          n.total ??
                                            n.grand_total ??
                                            n.net_total ??
                                            0
                                        )
                                      : s,
                                  0
                                )
                              );
                              const brekageValue = round2(
                                invs.reduce(
                                  (s, n) =>
                                    isBreakage(n)
                                      ? s +
                                        toNum(
                                          n.total ??
                                            n.grand_total ??
                                            n.net_total ??
                                            0
                                        )
                                      : s,
                                  0
                                )
                              );
                              const expiryValue = round2(
                                invs.reduce(
                                  (s, n) =>
                                    isExpired(n)
                                      ? s +
                                        toNum(
                                          n.total ??
                                            n.grand_total ??
                                            n.net_total ??
                                            0
                                        )
                                      : s,
                                  0
                                )
                              );
                              const returnValue = round2(
                                invs.reduce(
                                  (s, n) =>
                                    isReturnFlag(n)
                                      ? s +
                                        toNum(
                                          n.total ??
                                            n.grand_total ??
                                            n.net_total ??
                                            0
                                        )
                                      : s,
                                  0
                                )
                              );
                              const offerKey = `${team}|${hq}`;
                              const offer = offersByKey[offerKey] || {};
                              const claimVal = round2(offer.claimValue ?? 0);
                              const prodVal = round2(
                                offer.invoiceOffValue ?? 0
                              );
                              const priceVal = round2(
                                offer.invoiceOffPriceValue ?? 0
                              );
                              const rdVal = round2(offer.rdValue ?? 0);
                              const IncentiveValue = round2(
                                netValue + brekageValue
                              );
                              teamHqTotals.push({
                                team,
                                hq,
                                Sales: {
                                  grossValue,
                                  netValue,
                                  IncentiveValue
                                },
                                CN: {
                                  CNValue,
                                  expiryValue,
                                  returnValue,
                                  brekageValue
                                },
                                Offers: {
                                  claimValue: claimVal,
                                  prodValue: prodVal,
                                  priceValue: priceVal,
                                  rdValue: rdVal
                                }
                              });
                            });
                          });
                          const salesByTeamHQ = teamHqTotals.reduce(
                            (m, r) => ((m[`${r.team}|${r.hq}`] = r), m),
                            {}
                          );
                          const keys = new Set(Object.keys(salesByTeamHQ));
                          const toSection = (name, pairs) => ({
                            Name: name,
                            data: pairs
                              .filter(([Title, v]) => v != null)
                              .map(([Title, v]) => ({
                                Title,
                                Values: round2(Number(v) || 0)
                              }))
                          });
                          const sortInvoices = arr =>
                            (arr || []).sort(
                              (a, b) =>
                                String(b.PostingDate || "").localeCompare(
                                  String(a.PostingDate || "")
                                ) ||
                                String(a.Invoice).localeCompare(
                                  String(b.Invoice)
                                ) ||
                                Number(b.Net ?? 0) - Number(a.Net ?? 0)
                            );
                          const sortCust = (arr, keyPref = ["Net"]) => {
                            const sorted = [...arr].sort(
                              (a, b) =>
                                Number(b[keyPref[0]] ?? 0) -
                                  Number(a[keyPref[0]] ?? 0) ||
                                String(a.Customer).localeCompare(
                                  String(b.Customer)
                                )
                            );
                            const cap = Number($state.maxCustomers ?? 0);
                            return cap > 0 ? sorted.slice(0, cap) : sorted;
                          };
                          function collectTeamHQsForTeam(team) {
                            const hqs = new Set();
                            for (const key of Object.keys(invAgg_TCH)) {
                              const [t, , h] = key.split("|");
                              if (t === team) hqs.add(h);
                            }
                            return [...hqs];
                          }
                          function mapItemsForSection(section, itemsAll) {
                            const isReturnPurpose = purp => {
                              const p = (purp ?? "").toString().toUpperCase();
                              return (
                                p === "EXPIRED" ||
                                p === "SALES_RETURN" ||
                                p === "BREAKAGE" ||
                                p === "BREKAGE"
                              );
                            };
                            return (itemsAll || [])
                              .filter(it => {
                                const isOffer = !!(
                                  it?._isClaim ||
                                  it?._isFree ||
                                  it?._isRD
                                );
                                if (section === "Sales")
                                  return (
                                    !isReturnPurpose(it?.purpose) && !isOffer
                                  );
                                if (section === "Returns")
                                  return (
                                    isReturnPurpose(it?.purpose) && !isOffer
                                  );
                                return true;
                              })
                              .map(it => ({
                                Item: String(it.item_name ?? ""),
                                Amount: round2(Number(it.amount) || 0),
                                Qty: round2(Number(it.qty) || 0),
                                Purpose: String(it.purpose ?? "")
                              }));
                          }
                          function getBreakoutCustomers(
                            team,
                            hqOrNull,
                            section
                          ) {
                            const out = [];
                            const hqList = hqOrNull
                              ? [hqOrNull]
                              : collectTeamHQsForTeam(team);
                            for (const hq of hqList) {
                              const custMap = {};
                              if (
                                section === "Sales" ||
                                section === "Returns"
                              ) {
                                for (const iv of Object.values(invAgg_TCH)) {
                                  if (iv.team !== team || iv.hq !== hq)
                                    continue;
                                  const key = `${iv.customer}|${iv.ebs}`;
                                  custMap[key] ||= {
                                    id: iv.ebs || iv.customer,
                                    Customer: iv.customer,
                                    HQ: hq,
                                    Net: 0,
                                    invoices: []
                                  };
                                  if (
                                    section === "Sales" &&
                                    round2(iv.salesNet) > 0
                                  ) {
                                    const net = round2(iv.salesNet);
                                    custMap[key].Net += net;
                                    custMap[key].invoices.push({
                                      PostingDate: iv.PostingDate,
                                      Invoice: iv.Invoice,
                                      Net: net
                                    });
                                  }
                                  if (
                                    section === "Returns" &&
                                    round2(iv.creditNote) !== 0
                                  ) {
                                    const net = round2(iv.creditNote);
                                    custMap[key].Net += net;
                                    custMap[key].invoices.push({
                                      PostingDate: iv.PostingDate,
                                      Invoice: iv.Invoice,
                                      Net: net
                                    });
                                  }
                                }
                                for (const v of Object.values(custMap)) {
                                  v.Net = round2(v.Net);
                                  v.invoices = sortInvoices(v.invoices);
                                  out.push(v);
                                }
                              } else if (section === "Offers") {
                                for (const iv of Object.values(offerInv_TCH)) {
                                  if (iv.team !== team || iv.hq !== hq)
                                    continue;
                                  const hasAny =
                                    round2(iv.claim) ||
                                    round2(iv.prod) ||
                                    round2(iv.price) ||
                                    round2(iv.rd);
                                  if (!hasAny) continue;
                                  const key = `${iv.customer}|${iv.ebs}`;
                                  custMap[key] ||= {
                                    id: iv.ebs || iv.customer,
                                    Customer: iv.customer,
                                    HQ: hq,
                                    ClaimValue: 0,
                                    InvoiceOffValue: 0,
                                    InvoiceOffPriceValue: 0,
                                    RDValue: 0,
                                    TotalOffersValue: 0,
                                    invoices: []
                                  };
                                  custMap[key].ClaimValue += round2(iv.claim);
                                  custMap[key].InvoiceOffValue += round2(
                                    iv.prod
                                  );
                                  custMap[key].InvoiceOffPriceValue += round2(
                                    iv.price
                                  );
                                  custMap[key].RDValue += round2(iv.rd);
                                  custMap[key].TotalOffersValue += round2(
                                    iv.claim + iv.prod + iv.price + iv.rd
                                  );
                                  custMap[key].invoices.push({
                                    PostingDate: iv.PostingDate,
                                    Invoice: iv.Invoice,
                                    ClaimValue: round2(iv.claim),
                                    InvoiceOffValue: round2(iv.prod),
                                    InvoiceOffPriceValue: round2(iv.price),
                                    RDValue: round2(iv.rd)
                                  });
                                }
                                for (const v of Object.values(custMap)) {
                                  v.ClaimValue = round2(v.ClaimValue);
                                  v.InvoiceOffValue = round2(v.InvoiceOffValue);
                                  v.InvoiceOffPriceValue = round2(
                                    v.InvoiceOffPriceValue
                                  );
                                  v.RDValue = round2(v.RDValue);
                                  v.TotalOffersValue = round2(
                                    v.TotalOffersValue
                                  );
                                  v.invoices = sortInvoices(v.invoices);
                                  out.push(v);
                                }
                              }
                            }
                            const keyPref =
                              section === "Offers"
                                ? ["TotalOffersValue"]
                                : ["Net"];
                            return sortCust(out, keyPref);
                          }
                          function getBreakoutInvoices(
                            team,
                            hqOrNull,
                            section
                          ) {
                            const out = [];
                            if (section === "Sales" || section === "Returns") {
                              for (const iv of Object.values(invAgg_TCH)) {
                                if (iv.team !== team) continue;
                                if (hqOrNull && iv.hq !== hqOrNull) continue;
                                if (
                                  section === "Sales" &&
                                  round2(iv.salesNet) > 0
                                ) {
                                  out.push({
                                    Invoice: iv.Invoice,
                                    PostingDate: iv.PostingDate,
                                    Customer: iv.customer,
                                    Net: round2(iv.salesNet),
                                    items: mapItemsForSection(
                                      "Sales",
                                      iv.itemsAll
                                    )
                                  });
                                }
                                if (
                                  section === "Returns" &&
                                  round2(iv.creditNote) !== 0
                                ) {
                                  out.push({
                                    Invoice: iv.Invoice,
                                    PostingDate: iv.PostingDate,
                                    Customer: iv.customer,
                                    Net: round2(iv.creditNote),
                                    items: mapItemsForSection(
                                      "Returns",
                                      iv.itemsAll
                                    )
                                  });
                                }
                              }
                            } else if (section === "Offers") {
                              for (const iv of Object.values(offerInv_TCH)) {
                                if (iv.team !== team) continue;
                                if (hqOrNull && iv.hq !== hqOrNull) continue;
                                if (
                                  round2(iv.claim) ||
                                  round2(iv.prod) ||
                                  round2(iv.price) ||
                                  round2(iv.rd)
                                ) {
                                  out.push({
                                    Invoice: iv.Invoice,
                                    PostingDate: iv.PostingDate,
                                    Customer: iv.customer,
                                    ClaimValue: round2(iv.claim),
                                    InvoiceOffValue: round2(iv.prod),
                                    InvoiceOffPriceValue: round2(iv.price),
                                    RDValue: round2(iv.rd),
                                    items: (iv.itemsOffer || []).map(it => ({
                                      Item: String(it.item_name ?? ""),
                                      Amount: round2(Number(it.amount) || 0),
                                      Qty: round2(Number(it.qty) || 0),
                                      Purpose: String(it.purpose ?? "")
                                    }))
                                  });
                                }
                              }
                            }
                            return sortInvoices(out);
                          }
                          const custAgg_THCE = {};
                          for (const iv of Object.values(invAgg_TCH)) {
                            const key = `${iv.team}|${iv.hq}|${iv.customer}|${iv.ebs}`;
                            custAgg_THCE[key] ||= {
                              team: iv.team,
                              hq: iv.hq,
                              customer: iv.customer,
                              ebs: iv.ebs,
                              salesNet: 0,
                              expiry: 0,
                              returns: 0,
                              breakage: 0,
                              creditNote: 0
                            };
                            custAgg_THCE[key].salesNet += round2(iv.salesNet);
                            custAgg_THCE[key].creditNote += round2(
                              iv.creditNote
                            );
                            for (const it of iv.itemsAll) {
                              const purp = (it?.purpose ?? "").toUpperCase();
                              if (purp === "EXPIRED")
                                custAgg_THCE[key].expiry += round2(it.amount);
                              else if (purp === "SALES_RETURN")
                                custAgg_THCE[key].returns += round2(it.amount);
                              else if (
                                purp === "BREAKAGE" ||
                                purp === "BREKAGE"
                              )
                                custAgg_THCE[key].breakage += round2(it.amount);
                            }
                          }
                          const custOffer_THCE = {};
                          for (const iv of Object.values(offerInv_TCH)) {
                            const key = `${iv.team}|${iv.hq}|${iv.customer}|${iv.ebs}`;
                            custOffer_THCE[key] ||= {
                              team: iv.team,
                              hq: iv.hq,
                              customer: iv.customer,
                              ebs: iv.ebs,
                              claim: 0,
                              prod: 0,
                              price: 0,
                              rd: 0
                            };
                            custOffer_THCE[key].claim += round2(iv.claim);
                            custOffer_THCE[key].prod += round2(iv.prod);
                            custOffer_THCE[key].price += round2(iv.price);
                            custOffer_THCE[key].rd += round2(iv.rd);
                          }
                          function buildCustomerModelFromAgg(agg, offer = {}) {
                            return [
                              toSection("Sales", [
                                ["Gross", round2(agg.salesNet)],

                                ["Net", round2(agg.salesNet)]
                              ]),
                              toSection("Returns", [
                                ["Expiry", round2(agg.expiry)],

                                ["Return", round2(agg.returns)],

                                ["Breakage", round2(agg.breakage)]
                              ]),
                              toSection("Offers", [
                                ["Claim", round2(offer.claim ?? 0)],

                                ["Prod", round2(offer.prod ?? 0)],

                                ["Price", round2(offer.price ?? 0)],

                                ["RD", round2(offer.rd ?? 0)]
                              ])
                            ];
                          }
                          function buildCustomerModels(team, hqOrNull) {
                            const out = [];
                            for (const [key, agg] of Object.entries(
                              custAgg_THCE
                            )) {
                              if (agg.team !== team) continue;
                              if (hqOrNull && agg.hq !== hqOrNull) continue;
                              const offer = custOffer_THCE[key] || {};
                              out.push({
                                Customer: agg.customer,
                                EBSCode: agg.ebs,
                                HQ: agg.hq,
                                team: agg.team,
                                Model: buildCustomerModelFromAgg(agg, offer)
                              });
                            }
                            out.sort((a, b) => {
                              const aSales =
                                a.Model?.[0]?.data?.find(d => d.Title === "Net")
                                  ?.Values ?? 0;
                              const bSales =
                                b.Model?.[0]?.data?.find(d => d.Title === "Net")
                                  ?.Values ?? 0;
                              return (
                                bSales - aSales ||
                                String(a.Customer).localeCompare(
                                  String(b.Customer)
                                )
                              );
                            });
                            const cap = Number($state.maxCustomers ?? 0);
                            return cap > 0 ? out.slice(0, cap) : out;
                          }
                          const _teamHqWithTargets = [];
                          for (const key of keys) {
                            const [team, hq] = key.split("|");
                            if (!isTeamAllowed(team)) continue;
                            const sRow = salesByTeamHQ[key] ?? {
                              team,
                              hq,
                              Sales: {
                                grossValue: 0,
                                netValue: 0,
                                IncentiveValue: 0
                              },
                              CN: {
                                CNValue: 0,
                                expiryValue: 0,
                                returnValue: 0,
                                brekageValue: 0
                              },
                              Offers: {
                                claimValue: 0,
                                prodValue: 0,
                                priceValue: 0,
                                rdValue: 0
                              }
                            };
                            const s = sRow.Sales || {};
                            const c = sRow.CN || {};
                            const o = sRow.Offers || {};
                            const targetValue = round2(
                              Number(targetByTeamHQ[key] ?? 0)
                            );
                            const incentiveValue = round2(
                              Number(s.IncentiveValue ?? 0)
                            );
                            const Model = [
                              {
                                ...toSection("Sales", [
                                  ["Gross", s.grossValue],

                                  ["Net", s.netValue]
                                ]),
                                BreakoutCustomer: getBreakoutCustomers(
                                  team,
                                  hq,
                                  "Sales"
                                ),
                                BreakoutInvoice: getBreakoutInvoices(
                                  team,
                                  hq,
                                  "Sales"
                                )
                              },
                              {
                                ...toSection("Returns", [
                                  ["Expiry", c.expiryValue],

                                  ["Return", c.returnValue],

                                  ["Breakage", c.brekageValue]
                                ]),
                                BreakoutCustomer: getBreakoutCustomers(
                                  team,
                                  hq,
                                  "Returns"
                                ),
                                BreakoutInvoice: getBreakoutInvoices(
                                  team,
                                  hq,
                                  "Returns"
                                )
                              },
                              {
                                ...toSection("Offers", [
                                  ["Claim", o.claimValue],

                                  ["Prod", o.prodValue],

                                  ["Price", o.priceValue],

                                  ["RD", o.rdValue]
                                ]),
                                BreakoutCustomer: getBreakoutCustomers(
                                  team,
                                  hq,
                                  "Offers"
                                ),
                                BreakoutInvoice: getBreakoutInvoices(
                                  team,
                                  hq,
                                  "Offers"
                                )
                              }
                            ];

                            _teamHqWithTargets.push({
                              team,
                              hq,
                              Target: {
                                value: targetValue,
                                month: targetMonth || null
                              },
                              IncentiveValue: incentiveValue,
                              Model,
                              CustomerModels: buildCustomerModels(team, hq)
                            });
                          }
                          const agg = {};
                          for (const r of teamHqTotals) {
                            if (!isTeamAllowed(r.team)) continue;
                            const t = r.team;
                            agg[t] ||= {
                              sales_gross: 0,
                              sales_net: 0,
                              returns_expiry: 0,
                              returns_return: 0,
                              returns_brekage: 0,
                              rd: 0,
                              target: 0,
                              claim: 0,
                              prod: 0,
                              price: 0
                            };
                            agg[t].sales_gross += Number(
                              r.Sales?.grossValue ?? 0
                            );
                            agg[t].sales_net += Number(r.Sales?.netValue ?? 0);
                            agg[t].returns_expiry += Number(
                              r.CN?.expiryValue ?? 0
                            );
                            agg[t].returns_return += Number(
                              r.CN?.returnValue ?? 0
                            );
                            agg[t].returns_brekage += Number(
                              r.CN?.brekageValue ?? 0
                            );
                            agg[t].claim += Number(r.Offers?.claimValue ?? 0);
                            agg[t].prod += Number(r.Offers?.prodValue ?? 0);
                            agg[t].price += Number(r.Offers?.priceValue ?? 0);
                            agg[t].rd += Number(r.Offers?.rdValue ?? 0);
                          }
                          for (const [key, val] of Object.entries(
                            targetByTeamHQ
                          )) {
                            const [team] = key.split("|");
                            if (!isTeamAllowed(team)) continue;
                            agg[team] ||= {
                              sales_gross: 0,
                              sales_net: 0,
                              returns_expiry: 0,
                              returns_return: 0,
                              returns_brekage: 0,
                              rd: 0,
                              target: 0,
                              claim: 0,
                              prod: 0,
                              price: 0
                            };
                            agg[team].target += Number(val ?? 0);
                          }
                          const teamMap = {};
                          for (const row of _teamHqWithTargets) {
                            if (!isTeamAllowed(row.team)) continue;
                            const name = row.team;
                            if (!teamMap[name]) {
                              const teamColor = pickTeamColor(name);
                              teamMap[name] = {
                                Name: name,
                                Target: 0,
                                color: teamColor,
                                HQ: []
                              };
                            }
                            teamMap[name].Target += Number(
                              row?.Target?.value ?? 0
                            );
                            teamMap[name].HQ.push({
                              Type: "HQ",
                              color: HQ_COLOR,
                              hq: row.hq,
                              Target: row.Target,
                              Incentive: row.IncentiveValue,
                              Model: row.Model,
                              CustomerModels: row.CustomerModels
                            });
                          }
                          for (const name of Object.keys(teamMap)) {
                            const a = agg[name] || {};
                            const incentive = round2(
                              (a.sales_net ?? 0) + (a.returns_brekage ?? 0)
                            );
                            const teamModel = [
                              {
                                ...toSection("Sales", [
                                  ["Gross", round2(a.sales_gross ?? 0)],

                                  ["Net", round2(a.sales_net ?? 0)]
                                ]),
                                BreakoutCustomer: getBreakoutCustomers(
                                  name,
                                  null,
                                  "Sales"
                                ),
                                BreakoutInvoice: getBreakoutInvoices(
                                  name,
                                  null,
                                  "Sales"
                                )
                              },
                              {
                                ...toSection("Returns", [
                                  ["Expiry", round2(a.returns_expiry ?? 0)],

                                  ["Return", round2(a.returns_return ?? 0)],

                                  ["Breakage", round2(a.returns_brekage ?? 0)]
                                ]),
                                BreakoutCustomer: getBreakoutCustomers(
                                  name,
                                  null,
                                  "Returns"
                                ),
                                BreakoutInvoice: getBreakoutInvoices(
                                  name,
                                  null,
                                  "Returns"
                                )
                              },
                              {
                                ...toSection("Offers", [
                                  ["Claim", round2(a.claim ?? 0)],

                                  ["Prod", round2(a.prod ?? 0)],

                                  ["Price", round2(a.price ?? 0)],

                                  ["RD", round2(a.rd ?? 0)]
                                ]),
                                BreakoutCustomer: getBreakoutCustomers(
                                  name,
                                  null,
                                  "Offers"
                                ),
                                BreakoutInvoice: getBreakoutInvoices(
                                  name,
                                  null,
                                  "Offers"
                                )
                              }
                            ];

                            teamMap[name].Target = round2(
                              teamMap[name].Target || a.target || 0
                            );
                            teamMap[name].Incentive = incentive;
                            teamMap[name].Model = teamModel;
                            teamMap[name].HQ.sort((x, y) =>
                              String(x.hq).localeCompare(String(y.hq))
                            );
                            teamMap[name].CustomerModels = buildCustomerModels(
                              name,
                              null
                            );
                          }
                          const teamsElevated = Object.values(teamMap);
                          return { teamsElevated };
                        })();
                      }
                    };
                    return (({ customFunction }) => {
                      return customFunction();
                    })?.apply(null, [actionArgs]);
                  })()
                : undefined;
              if (
                $steps["logic"] != null &&
                typeof $steps["logic"] === "object" &&
                typeof $steps["logic"].then === "function"
              ) {
                $steps["logic"] = await $steps["logic"];
              }

              $steps["updateTotals4"] = true
                ? (() => {
                    const actionArgs = {
                      variable: {
                        objRoot: $state,
                        variablePath: ["items"]
                      },
                      operation: 0,
                      value: $steps?.logic?.teamsElevated
                    };
                    return (({ variable, value, startIndex, deleteCount }) => {
                      if (!variable) {
                        return;
                      }
                      const { objRoot, variablePath } = variable;

                      $stateSet(objRoot, variablePath, value);
                      return value;
                    })?.apply(null, [actionArgs]);
                  })()
                : undefined;
              if (
                $steps["updateTotals4"] != null &&
                typeof $steps["updateTotals4"] === "object" &&
                typeof $steps["updateTotals4"].then === "function"
              ) {
                $steps["updateTotals4"] = await $steps["updateTotals4"];
              }

              $steps["updateTotals5"] = true
                ? (() => {
                    const actionArgs = {
                      customFunction: async () => {
                        return (() => {
                          const w =
                            $steps.query?.data?.response?.data?.withPurpose
                              ?.edges ?? [];
                          const wo =
                            $steps.query?.data?.response?.data?.withoutPurpose
                              ?.edges ?? [];
                          const tEdges =
                            $steps.query?.data?.response?.data?.Targets
                              ?.edges ?? [];
                          const invoices = [...w, ...wo];

                          const TEAM_LIST = Array.isArray($state.teams)
                            ? $state.teams
                            : [];
                          const norm = s =>
                            String(s ?? "")
                              .trim()
                              .toLowerCase();
                          const ALLOW = new Set(TEAM_LIST.map(norm));
                          const allowAll = ALLOW.size === 0;
                          const isTeamAllowed = name =>
                            allowAll || ALLOW.has(norm(name));
                          const rowsAll =
                            $ctx.fn.explodeWithParent(invoices, {
                              itemPath: "node.items"
                            }) || [];
                          const teamKey = r =>
                            (r?.fsl_elbrit_sales_team__name ?? "Unknown")
                              .toString()
                              .trim();
                          const hqKey = r =>
                            (r?.territory__name ?? "Unknown").toString().trim();
                          const rows = rowsAll.filter(r =>
                            isTeamAllowed(teamKey(r))
                          );
                          const invoiceKey = r =>
                            (r?.name ?? r?.node?.name ?? "").toString();
                          const round2 = v =>
                            Math.round((Number(v) || 0) * 100) / 100;
                          const toNum = v => {
                            const n = Number(v);
                            return Number.isFinite(n) ? n : 0;
                          };
                          const pstr = n =>
                            (n?.fsl_purpose ?? "")
                              .toString()
                              .trim()
                              .toUpperCase();
                          const isBreakage = n =>
                            pstr(n) === "BREAKAGE" || pstr(n) === "BREKAGE";
                          const isExpired = n => pstr(n) === "EXPIRED";
                          const isReturn = n => pstr(n) === "SALES_RETURN";
                          const isRateDiff = n => {
                            const p = pstr(n)
                              .replace(/[-_]+/g, " ")
                              .replace(/\s+/g, " ")
                              .trim();
                            return p === "RATE DIFFERENCE" || p === "RD";
                          };
                          const uniqBy = (arr, keyFn) => {
                            const seen = new Set(),
                              out = [];
                            for (const x of arr) {
                              const k = keyFn(x);
                              if (!seen.has(k)) {
                                seen.add(k);
                                out.push(x);
                              }
                            }
                            return out;
                          };
                          const isClaimItem = r =>
                            toNum(r?.fsl_claim ?? r?.fslClaim) === 1;
                          const isInvoiceOffItem = r =>
                            toNum(r?.is_free_item ?? r?.isFreeItem) === 1;
                          const lineProductOfferValue = r =>
                            toNum(r?.qty) *
                            toNum(r?.fsl_pts ?? r?.fsl_PTS ?? r?.fslPts);
                          const linePriceOfferValue = r =>
                            toNum(r?.total ?? r?.net_amount ?? r?.amount ?? 0);
                          const hash32 = str => {
                            let h = 2166136261;
                            const s = String(str);
                            for (let i = 0; i < s.length; i++) {
                              h ^= s.charCodeAt(i);
                              h = Math.imul(h, 16777619);
                            }
                            return h >>> 0;
                          };
                          const hslToHex = (h, s, l) => {
                            s /= 100;
                            l /= 100;
                            const k = n => (n + h / 30) % 12;
                            const a = s * Math.min(l, 1 - l);
                            const f = n =>
                              l -
                              a *
                                Math.max(
                                  -1,
                                  Math.min(k(n) - 3, Math.min(9 - k(n), 1))
                                );
                            const toHex = x =>
                              Math.round(x * 255)
                                .toString(16)
                                .padStart(2, "0");
                            return `#${toHex(f(0))}${toHex(f(8))}${toHex(
                              f(4)
                            )}`;
                          };
                          const pickTeamColor = teamName => {
                            const h = hash32(teamName || "Unknown") % 360;
                            return hslToHex(h, 72, 48);
                          };
                          const HQ_COLOR = "#2798F5";
                          const byTeamHQ = rows.reduce((acc, r) => {
                            const t = teamKey(r),
                              h = hqKey(r);
                            acc[t] ||= {};
                            (acc[t][h] ||= []).push(r);
                            return acc;
                          }, {});
                          const teamHqTotals = [];
                          Object.entries(byTeamHQ).forEach(([team, hqMap]) => {
                            Object.entries(hqMap).forEach(([hq, arr]) => {
                              const invs = uniqBy(arr, invoiceKey);
                              const grossValue = round2(
                                invs.reduce(
                                  (s, n) => s + Math.abs(n.total ?? 0),
                                  0
                                )
                              );
                              const netValue = round2(
                                invs.reduce(
                                  (s, n) =>
                                    Number(n.is_return) === 0
                                      ? s + (n.total ?? 0)
                                      : s,
                                  0
                                )
                              );
                              const CNValue = round2(
                                invs.reduce(
                                  (s, n) =>
                                    Number(n.is_return) !== 0
                                      ? s + (n.total ?? 0)
                                      : s,
                                  0
                                )
                              );
                              const brekageValue = round2(
                                invs.reduce(
                                  (s, n) =>
                                    isBreakage(n) ? s + (n.total ?? 0) : s,
                                  0
                                )
                              );
                              const expiryValue = round2(
                                invs.reduce(
                                  (s, n) =>
                                    isExpired(n) ? s + (n.total ?? 0) : s,
                                  0
                                )
                              );
                              const returnValue = round2(
                                invs.reduce(
                                  (s, n) =>
                                    isReturn(n) ? s + (n.total ?? 0) : s,
                                  0
                                )
                              );
                              const rdValue = round2(
                                invs.reduce(
                                  (s, n) =>
                                    isRateDiff(n) ? s + (n.total ?? 0) : s,
                                  0
                                )
                              );
                              const IncentiveValue = round2(
                                netValue + brekageValue
                              );
                              teamHqTotals.push({
                                team,
                                hq,
                                Sales: {
                                  grossValue,
                                  netValue,
                                  IncentiveValue
                                },
                                CN: {
                                  CNValue,
                                  expiryValue,
                                  returnValue,
                                  brekageValue
                                },
                                RDValue: rdValue
                              });
                            });
                          });
                          const offerRows = rows.filter(
                            r => isClaimItem(r) || isInvoiceOffItem(r)
                          );
                          const offerAggTH = {};
                          for (const r of offerRows) {
                            const team = teamKey(r),
                              hq = hqKey(r),
                              key = `${team}|${hq}`;
                            if (!offerAggTH[key])
                              offerAggTH[key] = {
                                team,
                                hq,
                                claimValue: 0,
                                invoiceOffValue: 0,
                                invoiceOffPriceValue: 0
                              };
                            const prodVal = lineProductOfferValue(r);
                            const priceVal = linePriceOfferValue(r);
                            const claim = isClaimItem(r),
                              free = isInvoiceOffItem(r);
                            if (claim) offerAggTH[key].claimValue += prodVal;
                            if (free && !claim)
                              offerAggTH[key].invoiceOffValue += prodVal;
                            if (free && claim)
                              offerAggTH[key].invoiceOffPriceValue += priceVal;
                          }
                          const offersByTeamHQ = Object.values(offerAggTH).map(
                            o => ({
                              ...o,
                              claimValue: round2(o.claimValue),
                              invoiceOffValue: round2(o.invoiceOffValue),
                              invoiceOffPriceValue: round2(
                                o.invoiceOffPriceValue
                              )
                            })
                          );
                          const tNodesAll = tEdges
                            .map(e => e.node)
                            .filter(Boolean);
                          const teamKeyT = n =>
                            (n?.salesteam__name ?? "Unknown").toString().trim();
                          const hqKeyT = n =>
                            (n?.hq__name ?? "Unknown").toString().trim();
                          const tNodes = tNodesAll.filter(n =>
                            isTeamAllowed(teamKeyT(n))
                          );
                          const targetByTeamHQ = {};
                          let targetMonth = null;
                          for (const n of tNodes) {
                            const team = teamKeyT(n),
                              hq = hqKeyT(n),
                              key = `${team}|${hq}`;
                            const val = Number(n?.value ?? 0);
                            targetByTeamHQ[key] =
                              (targetByTeamHQ[key] ?? 0) + val;
                            if (!targetMonth && n?.date) targetMonth = n.date;
                          }
                          const salesByTeamHQ = teamHqTotals.reduce(
                            (m, r) => ((m[`${r.team}|${r.hq}`] = r), m),
                            {}
                          );
                          const offersByKey = offersByTeamHQ.reduce(
                            (m, o) => ((m[`${o.team}|${o.hq}`] = o), m),
                            {}
                          );
                          const keys = new Set([
                            ...Object.keys(salesByTeamHQ),
                            ...Object.keys(targetByTeamHQ),
                            ...Object.keys(offersByKey)
                          ]);
                          const toSection = (name, pairs) => ({
                            Name: name,
                            data: pairs
                              .filter(([Title, v]) => v != null)
                              .map(([Title, v]) => ({
                                Title,
                                Values: round2(Number(v) || 0)
                              }))
                          });
                          const teamHqWithTargets = [];
                          for (const key of keys) {
                            const [team, hq] = key.split("|");
                            const sRow = salesByTeamHQ[key] ?? {
                              team,
                              hq,
                              Sales: {
                                grossValue: 0,
                                netValue: 0,
                                IncentiveValue: 0
                              },
                              CN: {
                                CNValue: 0,
                                expiryValue: 0,
                                returnValue: 0,
                                brekageValue: 0
                              },
                              RDValue: 0
                            };
                            const s = sRow.Sales || {};
                            const o = offersByKey[key] || {};
                            const claimValue = Number(o.claimValue ?? 0);
                            const invoiceOffValue = Number(
                              o.invoiceOffValue ?? 0
                            );
                            const invoiceOffPriceValue = Number(
                              o.invoiceOffPriceValue ?? 0
                            );
                            const rdValue = Number(sRow.RDValue ?? 0);
                            const targetValue = round2(
                              Number(targetByTeamHQ[key] ?? 0)
                            );
                            const incentiveValue = round2(
                              Number(s.IncentiveValue ?? 0)
                            );
                            const Model = [
                              toSection("Sales", [
                                ["Gross Primary", s.grossValue],

                                ["Net Primary", s.netValue]
                              ]),
                              toSection("Returns", [
                                ["Expiry", sRow.CN?.expiryValue],

                                ["Sales Return", sRow.CN?.returnValue],

                                ["Breakage", sRow.CN?.brekageValue]
                              ]),
                              toSection("Offers", [
                                ["Claim Value", claimValue],

                                ["Product (Invoice Offer)", invoiceOffValue],

                                ["Price (Invoice Offer)", invoiceOffPriceValue],

                                ["Rate Difference", rdValue]
                              ])
                            ];

                            teamHqWithTargets.push({
                              team,
                              hq,
                              Target: {
                                value: targetValue,
                                month: targetMonth || null
                              },
                              IncentiveValue: incentiveValue,
                              Model
                            });
                          }
                          const agg = {};
                          for (const r of teamHqTotals) {
                            const t = r.team;
                            agg[t] ||= {
                              sales_gross: 0,
                              sales_net: 0,
                              returns_expiry: 0,
                              returns_return: 0,
                              returns_brekage: 0,
                              rd: 0,
                              target: 0,
                              claim: 0,
                              prod: 0,
                              price: 0
                            };
                            agg[t].sales_gross += Number(
                              r.Sales?.grossValue ?? 0
                            );
                            agg[t].sales_net += Number(r.Sales?.netValue ?? 0);
                            agg[t].returns_expiry += Number(
                              r.CN?.expiryValue ?? 0
                            );
                            agg[t].returns_return += Number(
                              r.CN?.returnValue ?? 0
                            );
                            agg[t].returns_brekage += Number(
                              r.CN?.brekageValue ?? 0
                            );
                            agg[t].rd += Number(r.RDValue ?? 0);
                          }
                          for (const o of offersByTeamHQ) {
                            const t = o.team;
                            agg[t] ||= {
                              sales_gross: 0,
                              sales_net: 0,
                              returns_expiry: 0,
                              returns_return: 0,
                              returns_brekage: 0,
                              rd: 0,
                              target: 0,
                              claim: 0,
                              prod: 0,
                              price: 0
                            };
                            agg[t].claim += Number(o.claimValue ?? 0);
                            agg[t].prod += Number(o.invoiceOffValue ?? 0);
                            agg[t].price += Number(o.invoiceOffPriceValue ?? 0);
                          }
                          for (const [key, val] of Object.entries(
                            targetByTeamHQ
                          )) {
                            const [team] = key.split("|");
                            agg[team] ||= {
                              sales_gross: 0,
                              sales_net: 0,
                              returns_expiry: 0,
                              returns_return: 0,
                              returns_brekage: 0,
                              rd: 0,
                              target: 0,
                              claim: 0,
                              prod: 0,
                              price: 0
                            };
                            agg[team].target += Number(val ?? 0);
                          }
                          const salesTeamWithTargets = Object.entries(agg)
                            .filter(([team]) => isTeamAllowed(team))
                            .map(([team, a]) => {
                              const incentive = round2(
                                (a.sales_net ?? 0) + (a.returns_brekage ?? 0)
                              );
                              const Model = [
                                toSection("Sales", [
                                  ["Gross Primary", round2(a.sales_gross ?? 0)],

                                  ["Net Primary", round2(a.sales_net ?? 0)]
                                ]),
                                toSection("Returns", [
                                  ["Expiry", round2(a.returns_expiry ?? 0)],

                                  [
                                    "Sales Return",
                                    round2(a.returns_return ?? 0)
                                  ],

                                  ["Breakage", round2(a.returns_brekage ?? 0)]
                                ]),
                                toSection("Offers", [
                                  ["Claim Value", round2(a.claim ?? 0)],

                                  [
                                    "Product (Invoice Offer)",
                                    round2(a.prod ?? 0)
                                  ],

                                  [
                                    "Price (Invoice Offer)",
                                    round2(a.price ?? 0)
                                  ],

                                  ["Rate Difference", round2(a.rd ?? 0)]
                                ])
                              ];

                              return {
                                team,
                                hq: "All HQs",
                                Target: {
                                  value: round2(a.target ?? 0),
                                  month: targetMonth || null
                                },
                                IncentiveValue: incentive,
                                Model
                              };
                            });
                          const teamMap = {};
                          for (const row of teamHqWithTargets) {
                            if (!isTeamAllowed(row.team)) continue;
                            const name = row.team;
                            if (!teamMap[name]) {
                              const teamColor = pickTeamColor(name);
                              teamMap[name] = {
                                Name: name,
                                Target: 0,
                                color: teamColor,
                                HQ: []
                              };
                            }
                            teamMap[name].Target += Number(
                              row?.Target?.value ?? 0
                            );
                            teamMap[name].HQ.push({
                              Type: "HQ",
                              color: HQ_COLOR,
                              hq: row.hq,
                              Target: row.Target,
                              IncentiveValue: row.IncentiveValue,
                              Model: row.Model
                            });
                          }
                          for (const name of Object.keys(teamMap)) {
                            const a = agg[name] || {};
                            const incentive = round2(
                              (a.sales_net ?? 0) + (a.returns_brekage ?? 0)
                            );
                            const teamModel = [
                              toSection("Sales", [
                                ["Gross Primary", round2(a.sales_gross ?? 0)],

                                ["Net Primary", round2(a.sales_net ?? 0)]
                              ]),
                              toSection("Returns", [
                                ["Expiry", round2(a.returns_expiry ?? 0)],

                                ["Sales Return", round2(a.returns_return ?? 0)],

                                ["Breakage", round2(a.returns_brekage ?? 0)]
                              ]),
                              toSection("Offers", [
                                ["Claim Value", round2(a.claim ?? 0)],

                                [
                                  "Product (Invoice Offer)",
                                  round2(a.prod ?? 0)
                                ],

                                ["Price (Invoice Offer)", round2(a.price ?? 0)],

                                ["Rate Difference", round2(a.rd ?? 0)]
                              ])
                            ];

                            teamMap[name].Target = round2(
                              teamMap[name].Target || a.target || 0
                            );
                            teamMap[name].IncentiveValue = incentive;
                            teamMap[name].Model = teamModel;
                            teamMap[name].HQ.sort((x, y) =>
                              String(x.hq).localeCompare(String(y.hq))
                            );
                          }
                          const teamsElevated = Object.values(teamMap);
                          return {
                            rows,
                            teamHqWithTargets,
                            salesTeamWithTargets,
                            teamsElevated
                          };
                        })();
                      }
                    };
                    return (({ customFunction }) => {
                      return customFunction();
                    })?.apply(null, [actionArgs]);
                  })()
                : undefined;
              if (
                $steps["updateTotals5"] != null &&
                typeof $steps["updateTotals5"] === "object" &&
                typeof $steps["updateTotals5"].then === "function"
              ) {
                $steps["updateTotals5"] = await $steps["updateTotals5"];
              }

              $steps["updateVariable"] = true
                ? (() => {
                    const actionArgs = {
                      variable: {
                        objRoot: $state,
                        variablePath: ["variable"]
                      },
                      operation: 0,
                      value: $steps.updateTotals5.rows
                    };
                    return (({ variable, value, startIndex, deleteCount }) => {
                      if (!variable) {
                        return;
                      }
                      const { objRoot, variablePath } = variable;

                      $stateSet(objRoot, variablePath, value);
                      return value;
                    })?.apply(null, [actionArgs]);
                  })()
                : undefined;
              if (
                $steps["updateVariable"] != null &&
                typeof $steps["updateVariable"] === "object" &&
                typeof $steps["updateVariable"].then === "function"
              ) {
                $steps["updateVariable"] = await $steps["updateVariable"];
              }
            }}
          />

          <Layout
            data-plasmic-name={"layout"}
            data-plasmic-override={overrides.layout}
            className={classNames("__wab_instance", sty.layout)}
          >
            {(_par => (!_par ? [] : Array.isArray(_par) ? _par : [_par]))(
              (() => {
                try {
                  return Object.entries($state.teams);
                } catch (e) {
                  if (
                    e instanceof TypeError ||
                    e?.plasmicType === "PlasmicUndefinedDataError"
                  ) {
                    return [];
                  }
                  throw e;
                }
              })()
            ).map((__plasmic_item_0, __plasmic_idx_0) => {
              const currentItem = __plasmic_item_0;
              const currentIndex = __plasmic_idx_0;
              return (
                <div
                  className={classNames(projectcss.all, sty.freeBox__uTSde)}
                  key={currentIndex}
                >
                  <div
                    className={classNames(
                      projectcss.all,
                      projectcss.__wab_text,
                      sty.text__flpei
                    )}
                  >
                    <React.Fragment>
                      {(() => {
                        try {
                          return currentItem[0];
                        } catch (e) {
                          if (
                            e instanceof TypeError ||
                            e?.plasmicType === "PlasmicUndefinedDataError"
                          ) {
                            return "Label";
                          }
                          throw e;
                        }
                      })()}
                    </React.Fragment>
                  </div>
                  <div
                    className={classNames(
                      projectcss.all,
                      projectcss.__wab_text,
                      sty.text__gZpwu
                    )}
                  >
                    <React.Fragment>
                      {(() => {
                        try {
                          return currentItem[1];
                        } catch (e) {
                          if (
                            e instanceof TypeError ||
                            e?.plasmicType === "PlasmicUndefinedDataError"
                          ) {
                            return "Label";
                          }
                          throw e;
                        }
                      })()}
                    </React.Fragment>
                  </div>
                </div>
              );
            })}
            <div className={classNames(projectcss.all, sty.freeBox__zenHg)}>
              <div className={classNames(projectcss.all, sty.freeBox__zwk5Q)}>
                <div className={classNames(projectcss.all, sty.freeBox__toAfx)}>
                  <Label
                    data-plasmic-name={"label"}
                    data-plasmic-override={overrides.label}
                    className={classNames("__wab_instance", sty.label)}
                  >
                    <div
                      className={classNames(projectcss.all, sty.freeBox__pc8NT)}
                    >
                      <div
                        className={classNames(
                          projectcss.all,
                          projectcss.__wab_text,
                          sty.text__u8Yjl
                        )}
                      >
                        {"Select Month"}
                      </div>
                      {(() => {
                        const child$Props = {
                          bordered: true,
                          className: classNames(
                            "__wab_instance",
                            sty.timePicker
                          ),
                          onChange: async (...eventArgs: any) => {
                            generateStateOnChangePropForCodeComponents(
                              $state,
                              "value",
                              ["timePicker", "value"],
                              AntdDatePicker_Helpers
                            ).apply(null, eventArgs);

                            (async value => {
                              const $steps = {};

                              $steps["updateDate"] = true
                                ? (() => {
                                    const actionArgs = {
                                      variable: {
                                        objRoot: $state,
                                        variablePath: ["date"]
                                      },
                                      operation: 0,
                                      value: (() => {
                                        const v = value || new Date(); // fallback to "now" if nothing selected

                                        // Convert to Date
                                        const d =
                                          v instanceof Date
                                            ? v
                                            : /^\d{4}-\d{2}$/.test(String(v))
                                            ? new Date(
                                                String(v) + "-01T00:00:00.000Z"
                                              )
                                            : new Date(String(v));

                                        // Bail if invalid
                                        if (
                                          !d ||
                                          !d.getTime ||
                                          Number.isNaN(d.getTime())
                                        ) {
                                          const now = new Date();
                                          const y = now.getUTCFullYear();
                                          const m = now.getUTCMonth();
                                          const fmt = dt =>
                                            dt.toISOString().slice(0, 10);
                                          return {
                                            startDate: fmt(
                                              new Date(Date.UTC(y, m, 1))
                                            ),
                                            endDate: fmt(
                                              new Date(Date.UTC(y, m + 1, 0))
                                            )
                                          };
                                        }

                                        const y = d.getUTCFullYear();
                                        const m = d.getUTCMonth();
                                        const fmt = dt =>
                                          dt.toISOString().slice(0, 10);

                                        return {
                                          startDate: fmt(
                                            new Date(Date.UTC(y, m, 1))
                                          ),
                                          endDate: fmt(
                                            new Date(Date.UTC(y, m + 1, 0))
                                          )
                                        };
                                      })()
                                    };
                                    return (({
                                      variable,
                                      value,
                                      startIndex,
                                      deleteCount
                                    }) => {
                                      if (!variable) {
                                        return;
                                      }
                                      const { objRoot, variablePath } =
                                        variable;

                                      $stateSet(objRoot, variablePath, value);
                                      return value;
                                    })?.apply(null, [actionArgs]);
                                  })()
                                : undefined;
                              if (
                                $steps["updateDate"] != null &&
                                typeof $steps["updateDate"] === "object" &&
                                typeof $steps["updateDate"].then === "function"
                              ) {
                                $steps["updateDate"] = await $steps[
                                  "updateDate"
                                ];
                              }
                            }).apply(null, eventArgs);
                          },
                          picker: "month",
                          popupScopeClassName:
                            sty["timePicker__datePickerPopup"],
                          showTime: false,
                          value: generateStateValueProp($state, [
                            "timePicker",
                            "value"
                          ])
                        };
                        initializeCodeComponentStates(
                          $state,
                          [
                            {
                              name: "value",
                              plasmicStateName: "timePicker.value"
                            }
                          ],
                          [],
                          AntdDatePicker_Helpers ?? {},
                          child$Props
                        );

                        return (
                          <AntdDatePicker
                            data-plasmic-name={"timePicker"}
                            data-plasmic-override={overrides.timePicker}
                            {...child$Props}
                          />
                        );
                      })()}
                    </div>
                  </Label>
                  <TagFilterPrimeReact
                    data-plasmic-name={"tagFilterPrimeReact"}
                    data-plasmic-override={overrides.tagFilterPrimeReact}
                    allowDeselect={true}
                    className={classNames(
                      "__wab_instance",
                      sty.tagFilterPrimeReact
                    )}
                    colorScheme={"default"}
                    defaultSelected={[]}
                    display={"tag"}
                    enableTagColors={true}
                    icon={null}
                    iconPos={"left"}
                    maxSelections={25}
                    multiSelect={true}
                    onSelectionChange={async (selectedTags, clickedTag) => {
                      const $steps = {};

                      $steps["updateTeams3"] = true
                        ? (() => {
                            const actionArgs = {
                              variable: {
                                objRoot: $state,
                                variablePath: ["teams"]
                              },
                              operation: 1
                            };
                            return (({
                              variable,
                              value,
                              startIndex,
                              deleteCount
                            }) => {
                              if (!variable) {
                                return;
                              }
                              const { objRoot, variablePath } = variable;

                              $stateSet(objRoot, variablePath, undefined);
                              return undefined;
                            })?.apply(null, [actionArgs]);
                          })()
                        : undefined;
                      if (
                        $steps["updateTeams3"] != null &&
                        typeof $steps["updateTeams3"] === "object" &&
                        typeof $steps["updateTeams3"].then === "function"
                      ) {
                        $steps["updateTeams3"] = await $steps["updateTeams3"];
                      }

                      $steps["updateTeams"] = true
                        ? (() => {
                            const actionArgs = {
                              variable: {
                                objRoot: $state,
                                variablePath: ["teams"]
                              },
                              operation: 0,
                              value: selectedTags
                            };
                            return (({
                              variable,
                              value,
                              startIndex,
                              deleteCount
                            }) => {
                              if (!variable) {
                                return;
                              }
                              const { objRoot, variablePath } = variable;

                              $stateSet(objRoot, variablePath, value);
                              return value;
                            })?.apply(null, [actionArgs]);
                          })()
                        : undefined;
                      if (
                        $steps["updateTeams"] != null &&
                        typeof $steps["updateTeams"] === "object" &&
                        typeof $steps["updateTeams"].then === "function"
                      ) {
                        $steps["updateTeams"] = await $steps["updateTeams"];
                      }

                      $steps["updateTeams2"] = false
                        ? (() => {
                            const actionArgs = {
                              args: [
                                "info",
                                (() => {
                                  try {
                                    return JSON.stringify($state.teams);
                                  } catch (e) {
                                    if (
                                      e instanceof TypeError ||
                                      e?.plasmicType ===
                                        "PlasmicUndefinedDataError"
                                    ) {
                                      return undefined;
                                    }
                                    throw e;
                                  }
                                })()
                              ]
                            };
                            return $globalActions[
                              "plasmic-antd5-config-provider.showNotification"
                            ]?.apply(null, [...actionArgs.args]);
                          })()
                        : undefined;
                      if (
                        $steps["updateTeams2"] != null &&
                        typeof $steps["updateTeams2"] === "object" &&
                        typeof $steps["updateTeams2"].then === "function"
                      ) {
                        $steps["updateTeams2"] = await $steps["updateTeams2"];
                      }
                    }}
                    searchDebounceMs={300}
                    searchLabel={"Search"}
                    searchPlaceholder={"Search Teams..."}
                    selectedLabel={"Selected"}
                    severity={"info"}
                    showSearch={true}
                    showSearchLabel={false}
                    size={"small"}
                    stateKey={"selectedTags"}
                    tagDataPath={""}
                    tagDataSource={"queryData"}
                    tagField={"name"}
                    tagList={(() => {
                      try {
                        return $queries.teams.data.response.data.ElbritSalesTeams.edges.map(
                          edge => edge.node.name
                        );
                      } catch (e) {
                        if (
                          e instanceof TypeError ||
                          e?.plasmicType === "PlasmicUndefinedDataError"
                        ) {
                          return [];
                        }
                        throw e;
                      }
                    })()}
                  />
                </div>
                <div className={classNames(projectcss.all, sty.freeBox__rnvad)}>
                  <Combobox
                    data-plasmic-name={"combobox"}
                    data-plasmic-override={overrides.combobox}
                    className={classNames("__wab_instance", sty.combobox)}
                    isOpen={generateStateValueProp($state, [
                      "combobox",
                      "isOpen"
                    ])}
                    items={
                      <MenuSection
                        data-plasmic-name={"menuSection"}
                        data-plasmic-override={overrides.menuSection}
                        className={classNames(
                          "__wab_instance",
                          sty.menuSection
                        )}
                        header={
                          <div
                            className={classNames(
                              projectcss.all,
                              projectcss.__wab_text,
                              sty.text__adk5Q
                            )}
                          >
                            {"Section"}
                          </div>
                        }
                        items={(_par =>
                          !_par ? [] : Array.isArray(_par) ? _par : [_par])(
                          (() => {
                            try {
                              return (() => {
                                return $queries.emp.data.response.data.Employees.edges.map(
                                  x => ({
                                    company_email: x.node.company_email,
                                    Name: x.node.employee_name
                                      ? `${x.node.name} - ${x.node.employee_name} - ${x.node.designation__name} - (${x.node.department__name})`
                                      : x.node.name
                                  })
                                );
                              })();
                            } catch (e) {
                              if (
                                e instanceof TypeError ||
                                e?.plasmicType === "PlasmicUndefinedDataError"
                              ) {
                                return [];
                              }
                              throw e;
                            }
                          })()
                        ).map((__plasmic_item_0, __plasmic_idx_0) => {
                          const currentItem = __plasmic_item_0;
                          const currentIndex = __plasmic_idx_0;
                          return (
                            <MenuItem
                              data-plasmic-name={"menuItem"}
                              data-plasmic-override={overrides.menuItem}
                              className={classNames(
                                "__wab_instance",
                                sty.menuItem
                              )}
                              key={currentIndex}
                              label={(() => {
                                try {
                                  return currentItem.Name;
                                } catch (e) {
                                  if (
                                    e instanceof TypeError ||
                                    e?.plasmicType ===
                                      "PlasmicUndefinedDataError"
                                  ) {
                                    return undefined;
                                  }
                                  throw e;
                                }
                              })()}
                              value={(() => {
                                try {
                                  return currentItem.Name;
                                } catch (e) {
                                  if (
                                    e instanceof TypeError ||
                                    e?.plasmicType ===
                                      "PlasmicUndefinedDataError"
                                  ) {
                                    return undefined;
                                  }
                                  throw e;
                                }
                              })()}
                            />
                          );
                        })}
                      />
                    }
                    label={
                      <div
                        className={classNames(
                          projectcss.all,
                          projectcss.__wab_text,
                          sty.text__nNjyq
                        )}
                      >
                        {"View As"}
                      </div>
                    }
                    onChange={async (...eventArgs: any) => {
                      generateStateOnChangeProp($state, [
                        "combobox",
                        "value"
                      ]).apply(null, eventArgs);

                      if (
                        eventArgs.length > 1 &&
                        eventArgs[1] &&
                        eventArgs[1]._plasmic_state_init_
                      ) {
                        return;
                      }
                    }}
                    onOpenChange={async (...eventArgs: any) => {
                      generateStateOnChangeProp($state, [
                        "combobox",
                        "isOpen"
                      ]).apply(null, eventArgs);

                      if (
                        eventArgs.length > 1 &&
                        eventArgs[1] &&
                        eventArgs[1]._plasmic_state_init_
                      ) {
                        return;
                      }
                    }}
                    placeholder={(() => {
                      try {
                        return (() => {
                          const firstName = (() => {
                            const n =
                              $queries.emp.data.response.data.Employees.edges[0]
                                .node;
                            return n.employee_name
                              ? `${n.name} - ${n.employee_name} - ${n.designation__name} - (${n.department__name})`
                              : n.name;
                          })();
                          return firstName;
                        })();
                      } catch (e) {
                        if (
                          e instanceof TypeError ||
                          e?.plasmicType === "PlasmicUndefinedDataError"
                        ) {
                          return undefined;
                        }
                        throw e;
                      }
                    })()}
                    value={generateStateValueProp($state, [
                      "combobox",
                      "value"
                    ])}
                  />

                  <Select
                    data-plasmic-name={"select"}
                    data-plasmic-override={overrides.select}
                    className={classNames("__wab_instance", sty.select)}
                    isOpen={generateStateValueProp($state, [
                      "select",
                      "isOpen"
                    ])}
                    onChange={async (...eventArgs: any) => {
                      generateStateOnChangeProp($state, [
                        "select",
                        "value"
                      ]).apply(null, eventArgs);

                      if (
                        eventArgs.length > 1 &&
                        eventArgs[1] &&
                        eventArgs[1]._plasmic_state_init_
                      ) {
                        return;
                      }
                    }}
                    onOpenChange={async (...eventArgs: any) => {
                      generateStateOnChangeProp($state, [
                        "select",
                        "isOpen"
                      ]).apply(null, eventArgs);

                      if (
                        eventArgs.length > 1 &&
                        eventArgs[1] &&
                        eventArgs[1]._plasmic_state_init_
                      ) {
                        return;
                      }
                    }}
                    value={generateStateValueProp($state, ["select", "value"])}
                  />
                </div>
              </div>
              <div className={classNames(projectcss.all, sty.freeBox__e9HAc)}>
                <MolKip
                  className={classNames("__wab_instance", sty.molKip__qC1N)}
                  name={"SALES"}
                  qty={(() => {
                    try {
                      return $state.teams.IncentiveQnt;
                    } catch (e) {
                      if (
                        e instanceof TypeError ||
                        e?.plasmicType === "PlasmicUndefinedDataError"
                      ) {
                        return undefined;
                      }
                      throw e;
                    }
                  })()}
                  sales={(() => {
                    try {
                      return $state.teams.IncentiveValue;
                    } catch (e) {
                      if (
                        e instanceof TypeError ||
                        e?.plasmicType === "PlasmicUndefinedDataError"
                      ) {
                        return undefined;
                      }
                      throw e;
                    }
                  })()}
                />

                <div className={classNames(projectcss.all, sty.freeBox__v08DR)}>
                  <MolKip
                    className={classNames("__wab_instance", sty.molKip__u5N4M)}
                    name={"Gross Sale"}
                    qty={(() => {
                      try {
                        return $state.teams.grossQnt;
                      } catch (e) {
                        if (
                          e instanceof TypeError ||
                          e?.plasmicType === "PlasmicUndefinedDataError"
                        ) {
                          return undefined;
                        }
                        throw e;
                      }
                    })()}
                    sales={(() => {
                      try {
                        return $state.teams.grossValue;
                      } catch (e) {
                        if (
                          e instanceof TypeError ||
                          e?.plasmicType === "PlasmicUndefinedDataError"
                        ) {
                          return undefined;
                        }
                        throw e;
                      }
                    })()}
                  />

                  <MolKip
                    className={classNames("__wab_instance", sty.molKip__fnIDl)}
                    name={"NET Sale"}
                    qty={(() => {
                      try {
                        return $state.teams.netQnt;
                      } catch (e) {
                        if (
                          e instanceof TypeError ||
                          e?.plasmicType === "PlasmicUndefinedDataError"
                        ) {
                          return undefined;
                        }
                        throw e;
                      }
                    })()}
                    sales={(() => {
                      try {
                        return $state.teams.netValue;
                      } catch (e) {
                        if (
                          e instanceof TypeError ||
                          e?.plasmicType === "PlasmicUndefinedDataError"
                        ) {
                          return undefined;
                        }
                        throw e;
                      }
                    })()}
                  />

                  <CnKpi
                    data-plasmic-name={"cnKpi"}
                    data-plasmic-override={overrides.cnKpi}
                    className={classNames("__wab_instance", sty.cnKpi)}
                    name={"CNSales"}
                    qty={(() => {
                      try {
                        return $state.teams.CNQnt;
                      } catch (e) {
                        if (
                          e instanceof TypeError ||
                          e?.plasmicType === "PlasmicUndefinedDataError"
                        ) {
                          return undefined;
                        }
                        throw e;
                      }
                    })()}
                    sales={(() => {
                      try {
                        return $state.teams.CNValue;
                      } catch (e) {
                        if (
                          e instanceof TypeError ||
                          e?.plasmicType === "PlasmicUndefinedDataError"
                        ) {
                          return undefined;
                        }
                        throw e;
                      }
                    })()}
                  >
                    <div
                      className={classNames(projectcss.all, sty.freeBox__wLfqr)}
                    >
                      <div
                        className={classNames(
                          projectcss.all,
                          sty.freeBox__jFQmX
                        )}
                      >
                        <div
                          className={classNames(
                            projectcss.all,
                            projectcss.__wab_text,
                            sty.text__vxqIz
                          )}
                        >
                          {"Return"}
                        </div>
                        <div
                          className={classNames(
                            projectcss.all,
                            projectcss.__wab_text,
                            sty.text__vuAav
                          )}
                        >
                          <React.Fragment>
                            {(() => {
                              try {
                                return `${$state.teams.returnValue} / ${$state.teams.returnQnt}`;
                              } catch (e) {
                                if (
                                  e instanceof TypeError ||
                                  e?.plasmicType === "PlasmicUndefinedDataError"
                                ) {
                                  return "";
                                }
                                throw e;
                              }
                            })()}
                          </React.Fragment>
                        </div>
                      </div>
                      <div
                        className={classNames(
                          projectcss.all,
                          sty.freeBox__dOtz
                        )}
                      >
                        <div
                          className={classNames(
                            projectcss.all,
                            projectcss.__wab_text,
                            sty.text__mxIjr
                          )}
                        >
                          {"Expiry"}
                        </div>
                        <div
                          className={classNames(
                            projectcss.all,
                            projectcss.__wab_text,
                            sty.text__b7QMa
                          )}
                        >
                          <React.Fragment>
                            {(() => {
                              try {
                                return `${$state.teams.expiryValue} / ${$state.teams.expiryQnt}`;
                              } catch (e) {
                                if (
                                  e instanceof TypeError ||
                                  e?.plasmicType === "PlasmicUndefinedDataError"
                                ) {
                                  return "";
                                }
                                throw e;
                              }
                            })()}
                          </React.Fragment>
                        </div>
                      </div>
                      <div
                        className={classNames(
                          projectcss.all,
                          sty.freeBox__gzyVm
                        )}
                      >
                        <div
                          className={classNames(
                            projectcss.all,
                            projectcss.__wab_text,
                            sty.text__u78Oa
                          )}
                        >
                          {"Breakage"}
                        </div>
                        <div
                          className={classNames(
                            projectcss.all,
                            projectcss.__wab_text,
                            sty.text__wCncw
                          )}
                        >
                          <React.Fragment>
                            {(() => {
                              try {
                                return `${$state.teams.brekageValue} / ${$state.teams.brekageQnt}`;
                              } catch (e) {
                                if (
                                  e instanceof TypeError ||
                                  e?.plasmicType === "PlasmicUndefinedDataError"
                                ) {
                                  return "";
                                }
                                throw e;
                              }
                            })()}
                          </React.Fragment>
                        </div>
                      </div>
                    </div>
                  </CnKpi>
                </div>
              </div>
            </div>
            {(_par => (!_par ? [] : Array.isArray(_par) ? _par : [_par]))(
              (() => {
                try {
                  return $state.items;
                } catch (e) {
                  if (
                    e instanceof TypeError ||
                    e?.plasmicType === "PlasmicUndefinedDataError"
                  ) {
                    return [];
                  }
                  throw e;
                }
              })()
            ).map((__plasmic_item_0, __plasmic_idx_0) => {
              const currentItem = __plasmic_item_0;
              const currentIndex = __plasmic_idx_0;
              return (
                <OrgSalesCardMix
                  data-plasmic-name={"orgSalesCardMix"}
                  data-plasmic-override={overrides.orgSalesCardMix}
                  className={classNames("__wab_instance", sty.orgSalesCardMix)}
                  data={(() => {
                    try {
                      return currentItem;
                    } catch (e) {
                      if (
                        e instanceof TypeError ||
                        e?.plasmicType === "PlasmicUndefinedDataError"
                      ) {
                        return {
                          Name: "Elbrit Trichy",
                          Target: 2500000,
                          HQ: [
                            {
                              hq: "HQ-Madurai",
                              Target: { value: 960000, month: "2025-07-01" },
                              IncentiveValue: 0,
                              Model: [
                                {
                                  Name: "Sales",
                                  data: [
                                    {
                                      Title: "Gross Primary",
                                      Values: 14256.69
                                    },
                                    { Title: "Net Primary", Values: 0 }
                                  ]
                                },
                                {
                                  Name: "Returns",
                                  data: [
                                    { Title: "Expiry", Values: -14256.69 },
                                    { Title: "Sales Return", Values: 0 },
                                    { Title: "Breakage", Values: 0 }
                                  ]
                                },
                                {
                                  Name: "Offers",
                                  data: [
                                    { Title: "Claim Value", Values: 0 },
                                    {
                                      Title: "Product (Invoice Offer)",
                                      Values: 0
                                    },
                                    {
                                      Title: "Price (Invoice Offer)",
                                      Values: 0
                                    },
                                    { Title: "Rate Difference", Values: 0 }
                                  ]
                                }
                              ]
                            },
                            {
                              hq: "HQ-Nagercoil",
                              Target: { value: 115000, month: "2025-07-01" },
                              IncentiveValue: 0,
                              Model: [
                                {
                                  Name: "Sales",
                                  data: [
                                    { Title: "Gross Primary", Values: 0 },
                                    { Title: "Net Primary", Values: 0 }
                                  ]
                                },
                                {
                                  Name: "Returns",
                                  data: [
                                    { Title: "Expiry", Values: 0 },
                                    { Title: "Sales Return", Values: 0 },
                                    { Title: "Breakage", Values: 0 }
                                  ]
                                },
                                {
                                  Name: "Offers",
                                  data: [
                                    { Title: "Claim Value", Values: 0 },
                                    {
                                      Title: "Product (Invoice Offer)",
                                      Values: 0
                                    },
                                    {
                                      Title: "Price (Invoice Offer)",
                                      Values: 0
                                    },
                                    { Title: "Rate Difference", Values: 0 }
                                  ]
                                }
                              ]
                            },
                            {
                              hq: "HQ-Tanjore",
                              Target: { value: 510000, month: "2025-07-01" },
                              IncentiveValue: 0,
                              Model: [
                                {
                                  Name: "Sales",
                                  data: [
                                    { Title: "Gross Primary", Values: 0 },
                                    { Title: "Net Primary", Values: 0 }
                                  ]
                                },
                                {
                                  Name: "Returns",
                                  data: [
                                    { Title: "Expiry", Values: 0 },
                                    { Title: "Sales Return", Values: 0 },
                                    { Title: "Breakage", Values: 0 }
                                  ]
                                },
                                {
                                  Name: "Offers",
                                  data: [
                                    { Title: "Claim Value", Values: 0 },
                                    {
                                      Title: "Product (Invoice Offer)",
                                      Values: 0
                                    },
                                    {
                                      Title: "Price (Invoice Offer)",
                                      Values: 0
                                    },
                                    { Title: "Rate Difference", Values: 0 }
                                  ]
                                }
                              ]
                            },
                            {
                              hq: "HQ-Tirunelveli",
                              Target: { value: 300000, month: "2025-07-01" },
                              IncentiveValue: 0,
                              Model: [
                                {
                                  Name: "Sales",
                                  data: [
                                    {
                                      Title: "Gross Primary",
                                      Values: 13824.73
                                    },
                                    { Title: "Net Primary", Values: 0 }
                                  ]
                                },
                                {
                                  Name: "Returns",
                                  data: [
                                    { Title: "Expiry", Values: -13824.73 },
                                    { Title: "Sales Return", Values: 0 },
                                    { Title: "Breakage", Values: 0 }
                                  ]
                                },
                                {
                                  Name: "Offers",
                                  data: [
                                    { Title: "Claim Value", Values: 0 },
                                    {
                                      Title: "Product (Invoice Offer)",
                                      Values: 0
                                    },
                                    {
                                      Title: "Price (Invoice Offer)",
                                      Values: 0
                                    },
                                    { Title: "Rate Difference", Values: 0 }
                                  ]
                                }
                              ]
                            },
                            {
                              hq: "HQ-Trichy",
                              Target: { value: 615000, month: "2025-07-01" },
                              IncentiveValue: 0,
                              Model: [
                                {
                                  Name: "Sales",
                                  data: [
                                    { Title: "Gross Primary", Values: 0 },
                                    { Title: "Net Primary", Values: 0 }
                                  ]
                                },
                                {
                                  Name: "Returns",
                                  data: [
                                    { Title: "Expiry", Values: 0 },
                                    { Title: "Sales Return", Values: 0 },
                                    { Title: "Breakage", Values: 0 }
                                  ]
                                },
                                {
                                  Name: "Offers",
                                  data: [
                                    { Title: "Claim Value", Values: 0 },
                                    {
                                      Title: "Product (Invoice Offer)",
                                      Values: 0
                                    },
                                    {
                                      Title: "Price (Invoice Offer)",
                                      Values: 0
                                    },
                                    { Title: "Rate Difference", Values: 0 }
                                  ]
                                }
                              ]
                            }
                          ],
                          IncentiveValue: 0,
                          Model: [
                            {
                              Name: "Sales",
                              data: [
                                { Title: "Gross Primary", Values: 28081.42 },
                                { Title: "Net Primary", Values: 0 }
                              ]
                            },
                            {
                              Name: "Returns",
                              data: [
                                { Title: "Expiry", Values: -28081.42 },
                                { Title: "Sales Return", Values: 0 },
                                { Title: "Breakage", Values: 0 }
                              ]
                            },
                            {
                              Name: "Offers",
                              data: [
                                { Title: "Claim Value", Values: 0 },
                                { Title: "Product (Invoice Offer)", Values: 0 },
                                { Title: "Price (Invoice Offer)", Values: 0 },
                                { Title: "Rate Difference", Values: 0 }
                              ]
                            }
                          ]
                        };
                      }
                      throw e;
                    }
                  })()}
                  key={currentIndex}
                />
              );
            })}
          </Layout>
        </div>
      </div>
    </React.Fragment>
  ) as React.ReactElement | null;
}

const PlasmicDescendants = {
  root: [
    "root",
    "sideEffect",
    "layout",
    "label",
    "timePicker",
    "tagFilterPrimeReact",
    "combobox",
    "menuSection",
    "menuItem",
    "select",
    "cnKpi",
    "orgSalesCardMix"
  ],
  sideEffect: ["sideEffect"],
  layout: [
    "layout",
    "label",
    "timePicker",
    "tagFilterPrimeReact",
    "combobox",
    "menuSection",
    "menuItem",
    "select",
    "cnKpi",
    "orgSalesCardMix"
  ],
  label: ["label", "timePicker"],
  timePicker: ["timePicker"],
  tagFilterPrimeReact: ["tagFilterPrimeReact"],
  combobox: ["combobox", "menuSection", "menuItem"],
  menuSection: ["menuSection", "menuItem"],
  menuItem: ["menuItem"],
  select: ["select"],
  cnKpi: ["cnKpi"],
  orgSalesCardMix: ["orgSalesCardMix"]
} as const;
type NodeNameType = keyof typeof PlasmicDescendants;
type DescendantsType<T extends NodeNameType> =
  (typeof PlasmicDescendants)[T][number];
type NodeDefaultElementType = {
  root: "div";
  sideEffect: typeof SideEffect;
  layout: typeof Layout;
  label: typeof Label;
  timePicker: typeof AntdDatePicker;
  tagFilterPrimeReact: typeof TagFilterPrimeReact;
  combobox: typeof Combobox;
  menuSection: typeof MenuSection;
  menuItem: typeof MenuItem;
  select: typeof Select;
  cnKpi: typeof CnKpi;
  orgSalesCardMix: typeof OrgSalesCardMix;
};

type ReservedPropsType = "variants" | "args" | "overrides";
type NodeOverridesType<T extends NodeNameType> = Pick<
  PlasmicHome__OverridesType,
  DescendantsType<T>
>;
type NodeComponentProps<T extends NodeNameType> =
  // Explicitly specify variants, args, and overrides as objects
  {
    variants?: PlasmicHome__VariantsArgs;
    args?: PlasmicHome__ArgsType;
    overrides?: NodeOverridesType<T>;
  } & Omit<PlasmicHome__VariantsArgs, ReservedPropsType> & // Specify variants directly as props
    // Specify args directly as props
    Omit<PlasmicHome__ArgsType, ReservedPropsType> &
    // Specify overrides for each element directly as props
    Omit<
      NodeOverridesType<T>,
      ReservedPropsType | VariantPropType | ArgPropType
    > &
    // Specify props for the root element
    Omit<
      Partial<React.ComponentProps<NodeDefaultElementType[T]>>,
      ReservedPropsType | VariantPropType | ArgPropType | DescendantsType<T>
    >;

function makeNodeComponent<NodeName extends NodeNameType>(nodeName: NodeName) {
  type PropsType = NodeComponentProps<NodeName> & { key?: React.Key };
  const func = function <T extends PropsType>(
    props: T & StrictProps<T, PropsType>
  ) {
    const { variants, args, overrides } = React.useMemo(
      () =>
        deriveRenderOpts(props, {
          name: nodeName,
          descendantNames: PlasmicDescendants[nodeName],
          internalArgPropNames: PlasmicHome__ArgProps,
          internalVariantPropNames: PlasmicHome__VariantProps
        }),
      [props, nodeName]
    );
    return PlasmicHome__RenderFunc({
      variants,
      args,
      overrides,
      forNode: nodeName
    });
  };
  if (nodeName === "root") {
    func.displayName = "PlasmicHome";
  } else {
    func.displayName = `PlasmicHome.${nodeName}`;
  }
  return func;
}

export const PlasmicHome = Object.assign(
  // Top-level PlasmicHome renders the root element
  makeNodeComponent("root"),
  {
    // Helper components rendering sub-elements
    sideEffect: makeNodeComponent("sideEffect"),
    layout: makeNodeComponent("layout"),
    label: makeNodeComponent("label"),
    timePicker: makeNodeComponent("timePicker"),
    tagFilterPrimeReact: makeNodeComponent("tagFilterPrimeReact"),
    combobox: makeNodeComponent("combobox"),
    menuSection: makeNodeComponent("menuSection"),
    menuItem: makeNodeComponent("menuItem"),
    select: makeNodeComponent("select"),
    cnKpi: makeNodeComponent("cnKpi"),
    orgSalesCardMix: makeNodeComponent("orgSalesCardMix"),

    // Metadata about props expected for PlasmicHome
    internalVariantProps: PlasmicHome__VariantProps,
    internalArgProps: PlasmicHome__ArgProps,

    // Page metadata
    pageMetadata: {
      title: "",
      description: "",
      ogImageSrc: "",
      canonical: ""
    }
  }
);

export default PlasmicHome;
/* prettier-ignore-end */
